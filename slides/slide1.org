#+OPTIONS: toc:nil ^:{} H:2 author:nil
#+STARTUP:     beamer
#+LATEX_CLASS: python-slide

* Présentation & organisation
** Titre
:PROPERTIES:
:BEAMER_ENV: fullframe
:END:

#+BEGIN_EXPORT beamer
\title{Présentation \& organisation}
\author{Xavier Garrido}
\institute{Laboratoire de l'Accélérateur Linéaire, Orsay}
\titlepage
#+END_EXPORT

** Pourquoi ce complément ?

Depuis 2015, dans le cadre de *la préparation à l'agrégation à Montrouge*, [[http://cdrom2016.agregation-physique.org/index.php/programmes-informatiques/programme-python][des interfaces graphiques]]
en *Python* relativement simples sont proposées afin d'illustrer les leçons

- Mécanique Quantique : Effet tunnel
- Optique : Diffraction par $N$ fentes
- Thermodynamique : Isothermes de Van der Waals

** Langage Python

#+BEGIN_QUOTE
Python est un langage de programmation, dont la première version est sortie en
*1991*. Créé par *Guido van Rossum*, il a voyagé du Macintosh de son créateur,
qui travaillait à cette époque au Centrum voor Wiskunde en Informatica aux
Pays-Bas, jusqu'à se voir associer une organisation à but non lucratif
particulièrement dévouée, la *[[https://www.python.org/][Python Software Foundation]]*, créée en 2001. Ce
langage a été baptisé ainsi en hommage à la troupe de comiques les *« Monty
Python »*.
#+END_QUOTE

** Langage Python : pourquoi ?

#+ATTR_LATEX: :width 0.55\linewidth
[[file:figures/python_xkcd.png]]

#+BEAMER:\scriptsize\hfill$^\dagger$
[[http://xkcd.com/353/][xkcd comic]]

** Langage Python : pourquoi ?

Pour tout un tas de (bonnes) raisons parmi lesquelles

#+BEAMER: \pause

- *Un langage simple et clair*
  - code facile à lire et intuitif,
  - visuellement épuré,
  - *syntaxe minimaliste* facile à apprendre,
  - moins de lignes de code, moins de bugs, plus facile à entretenir.

#+BEAMER: \pause
#+ATTR_BEAMER: :overlay +-
- Détails techniques :
  - *Type dynamique* : pas besoin de définir le type de variables, les arguments de
    fonction ou les types de retour.
  - *Gestion automatique de la mémoire* : pas besoin d'allouer et de désallouer
    explicitement la mémoire pour les variables et les tableaux de données. Pas
    de bugs de fuite de mémoire.
  - *Langage interprété* : Pas besoin de compiler le code. L'interpréteur Python lit et
    exécute directement le code python.

** Langage Python

#+BEGIN_REMARK
_Python 2 ou Python 3 ?_

En 2008, Python 3 a été officiellement lancé. Quelques (vielles) librairies
scientifiques ne fonctionnent pas encore sous Python 3 mais c'est de plus en
plus l'exception. Au cours de cet enseignement, nous utiliserons _Python 3.5_
#+END_REMARK

** Programme du cours

#+ATTR_LATEX: :options [100][-none][][1.25][4]
#+BEGIN_CBOX
- *Bases de la programmation en Python*
  - type de données, /containers/, bloc conditionnel, boucles =for=
  - fonctions, scripts & modules, entrées/sorties
#+END_CBOX

** Programme du cours

#+ATTR_LATEX: :options [100][-none][][1.25][4]
#+BEGIN_CBOX
- *Bases de la programmation en Python*
  - type de données, /containers/, bloc conditionnel, boucles =for=
  - fonctions, scripts & modules, entrées/sorties
#+END_CBOX

#+ATTR_LATEX: :options [100][-none][][1.25][7.5]
#+BEGIN_CBOX
- *Représentation graphique avec =matplotlib=*
  - gestion & manipulation données numériques (=numpy=)
  - création de figures, /subplots/, axes, légendes
  - histogramme, courbe de niveau, 3D
  - utilisation des /widgets/ de =matplotlib=
#+END_CBOX

** Programme du cours
:PROPERTIES:
:BEAMER_ENV: fullframe
:END:

#+ATTR_LATEX: :options [12][-none][][-0.5][0]
#+BEGIN_CBOX
[[file:figures/ligo_og.pdf]]
#+END_CBOX

** Programme du cours
:PROPERTIES:
:BEAMER_ENV: fullframe
:END:

#+ATTR_LATEX: :options [12][-none][][-0.5][0]
#+BEGIN_CBOX
[[file:figures/ligo_og.pdf]]
#+END_CBOX

#+ATTR_LATEX: :options [10][-none][][5][6]
#+BEGIN_CBOX
[[file:figures/planck_skymap.jpg]]
#+END_CBOX

** Notes/transparents de cours \faArchive
:PROPERTIES:
:BEAMER_OPT: fragile
:END:

*** Dokeos /tree/
:PROPERTIES:
:BEAMER_COL: 0.4
:END:

#+BEGIN_SRC latex
   \begin{tikzpicture}[%
    grow via three points={one child at (1.0,-0.7) and
      two children at (0.25,-0.7) and (0.25,-1.4)},
    edge from parent path={([xshift=8pt]\tikzparentnode.south west) |- (\tikzchildnode.west)},%
    line width=0.75pt]

    \newcommand{\closedDirectory}[1]{\faFolderO #1}
    \newcommand{\openedDirectory}[1]{\faFolderOpenO #1}
    \newcommand{\pdfFile}[1]{\faFileO #1}

    \tikzstyle{every node}=[anchor=west]
    \tikzstyle{selected}=[draw=blue,rounded corners,fill=blue!30,blue]
    \tikzstyle{optional}=[dashed,fill=gray!50]

    \node {\openedDirectory{Option "Python pour l'agrégation"}}
    %%   child { node[xshift=-20pt] {\pdfFile{annexe\_compilation}}}
    %% }
    %% child [missing] {}
    %% child { node {\closedDirectory{projets}}}
    child { node[xshift=-68pt] {\closedDirectory{td}}}
    child { node[xshift=-68pt] {\openedDirectory{transparents}}
      child { node[xshift=-28pt] {\pdfFile{01\_slide}}}
      child { node[xshift=-28pt,optional] {\pdfFile{02\_slide}}}
    };
  \end{tikzpicture}
#+END_SRC

*** Ressources Dokeos
:PROPERTIES:
:BEAMER_COL: 0.7
:END:
#+ATTR_LATEX: :options [][][\centering]
#+BEGIN_CBOX
_Ressources disponibles sur dokeos [[http://formation.u-psud.fr][http://formation.u-psud.fr]]_
#+END_CBOX

** Bibliographie \faBookmark

- /Open Classrooms/ : [[https://openclassrooms.com/courses/apprenez-a-programmer-en-python][Apprenez à programmer en Python]]
- [[https://github.com/jakevdp/PythonDataScienceHandbook][*Python Data Science Handbook*]]
- [[http://www.scipy-lectures.org/index.html][*Scipy Lectures Notes*]]
- [[https://github.com/jrjohansson/scientific-python-lectures][*Scientific Python Lectures*]]
- ...

** Outline
:PROPERTIES:
:BEAMER_ENV: fullframe
:END:

#+BEGIN_EXPORT beamer
\tableofcontents
#+END_EXPORT

* L'environnement Python
** Titre
:PROPERTIES:
:BEAMER_ENV: fullframe
:END:

#+BEGIN_EXPORT beamer
\title{L'environnement Python}
\titlepage
#+END_EXPORT

** Interpréteurs =python=

- Interpréteur standard @@beamer:\onslide<2->{$\to$ utilisation limitée}@@
  #+BEAMER: \vskip5pt
  #+BEGIN_SRC python
    @\prompt@ python
    Python 3.5.2 (default, Oct 14 2016, 12:54:53)
    [GCC 6.2.1 20160916 (Red Hat 6.2.1-2)] on linux
    Type "help", "copyright", "credits" or "license" for more information.
    >>> 2*2
    4
    >>> exit()
  #+END_SRC

#+BEAMER: \pause\pause

- Interpréteur intéractif =ipython=
  - *historique des commandes* \to touches \faArrowCircleUp et \faArrowCircleDown
  - *auto-complétion* \to touche =<TAB>=
  - édition en ligne du code
  - extraction automatique de *la documentation des fonctions* et objets =python=
  - interaction avec le shell du système d'exploitation

** Interpréteur =ipython=

- Utilisation de =ipython=

  #+BEGIN_SRC python
    @\prompt@ ipython
    Python 3.5.2 (default, Oct 14 2016, 12:54:53)
    Type "copyright", "credits" or "license" for more information.

    IPython 5.1.0 -- An enhanced Interactive Python.
    ?         -> Introduction and overview of IPython's features.
    %quickref -> Quick reference.
    help      -> Python's own help system.
    object?   -> Details about 'object', use 'object??' for extra details.

    In [1]: 2*2
    Out[1]: 4
  #+END_SRC

** Interpréteur =ipython=

- Premier programme =python= : /"Hello world"/

  #+BEGIN_SRC python
    In [1]: print("Hello world")
    Hello world
  #+END_SRC

#+BEAMER: \pause

- Obtenir de l'aide /via/ l'opérateur =?=

  #+BEGIN_SRC python
    In [2]: print?
    Docstring:
    print(value, ..., sep=' ', end='\n', file=sys.stdout, flush=False)

    Prints the values to a stream, or to sys.stdout by default.
    Optional keyword arguments:
    file:  a file-like object (stream); defaults to the current sys.stdout.
    sep:   string inserted between values, default a space.
    end:   string appended after the last value, default a newline.
    flush: whether to forcibly flush the stream.
    Type:      builtin_function_or_method
  #+END_SRC
** Interpréteur =ipython=

- Historique des commandes

  #+BEGIN_SRC python
    In [1]: x = 10

    In [2]: <UP>

    In [2]: x = 10
  #+END_SRC

#+BEAMER: \pause

- Auto-complétion

  #+BEGIN_SRC python
    In [1]: x = 10

    In [2]: x.<TAB>
    x.bit_length   x.denominator  x.imag         x.real
    x.conjugate    x.from_bytes   x.numerator    x.to_bytes
  #+END_SRC

* Variables, structure conditionnelle et autres boucles
** Titre
:PROPERTIES:
:BEAMER_ENV: fullframe
:END:

#+BEGIN_EXPORT beamer
\title{Variables, structure conditionnelle et autres boucles}
\titlepage
#+END_EXPORT

** Déclaration de variables

- En raison du *typage dynamique*, Python permet de déclarer des variables sans en
  préciser le type (entier, nombre flottant, ...)

#+BEAMER: \pause
#+BEGIN_SRC python
  In [1]: i = 2

  In [2]: x = 10.5

  In [3]: s = "Une noisette, j'la casse entre mes fesses tu vois... JCVD"
#+END_SRC

#+BEAMER:\pause
#+BEGIN_SRC python
  In [4]: %whos
  Variable   Type     Data/Info
  -----------------------------
  i          int      2
  s          str      Une noisette, j'la casse <...>es fesses tu vois... JCVD
  x          float    10.5
#+END_SRC


#+BEGIN_COMMENT
/cf./ cours
http://nbviewer.jupyter.org/github/jrjohansson/scientific-python-lectures/blob/master/Lecture-1-Introduction-to-Python-Programming.ipynb#Assignment

Affectation multiples /cf./ cours http://python.developpez.com/cours/apprendre-python3/?page=page_4#L4-G
#+END_COMMENT

** Type fondamentaux

#+ATTR_BEAMER: :overlay +-
- La fonction *=type=* permet d'accéder au type d'une variable

- *Nombre entier*

  #+BEGIN_SRC python
    In [1]: i = 2
    In [2]: type(i)
    Out[2]: int
  #+END_SRC

- *Nombre flottant*

  #+BEGIN_SRC python
    In [1]: x = 10.5
    In [2]: type(x)
    Out[2]: float
  #+END_SRC

** Type fondamentaux

#+ATTR_BEAMER: :overlay +-
- *Nombre complexe*

  #+BEGIN_SRC python
    In [1]: z = 1.5 + 0.5j
    In [2]: type(z)
    Out[2]: complex
    In [3]: z.real
    Out[3]: 1.5
    In [4]: z.imag
    Out[4]: 0.5
  #+END_SRC

#+BEGIN_REMARK
On notera que le nombre complexe $i$ est noté =j= ou =J= en Python

  #+BEGIN_SRC python
    In [1]: j = 5

    In [2]: 2 + 5*j
    Out[2]: 27

    In [3]: 2 + 5j
    Out[3]: (2+5j)
  #+END_SRC
#+END_REMARK

** Type fondamentaux

- *Booléen*

  #+BEGIN_SRC python
    In [1]: b = 3 > 4
    In [2]: type(b)
    Out[2]: bool
    In [3]: b
    Out[3]: False
  #+END_SRC

** Conversion explicite

- Nombre entier \to nombre flottant

  #+BEGIN_SRC python
    In [1]: i = 2
    In [2]: i
    Out[2]: 2
    In [3]: x = float(i)
    In [4]: x
    Out[4]: 2.0
  #+END_SRC

#+BEAMER: \pause
- Nombre entier \to booléen

  #+BEGIN_SRC python
    In [1]: b = bool(i)
    In [2]: b
    Out[2]: True
  #+END_SRC

#+BEGIN_REMARK
Toute valeur différente de 0 est considérée comme vraie
#+END_REMARK

#+BEGIN_COMMENT
/cf./ cours
http://nbviewer.jupyter.org/github/jrjohansson/scientific-python-lectures/blob/master/Lecture-1-Introduction-to-Python-Programming.ipynb#Type-casting
#+END_COMMENT

** Opérations & comparaisons

- Opérations arithmétiques =+=, =-=, =*=, =/=, =//= division entière, =**= puissance, =%= modulo

  #+BEGIN_SRC python
    In [1]: 1 + 2, 1 - 2, 1 * 2, 1 / 2
    Out[1]: (3, -1, 2, 0)

    In [2]: 1.0 + 2.0, 1.0 - 2.0, 1.0 * 2.0, 1.0 / 2.0
    Out[2]: (3.0, -1.0, 2.0, 0.5)

    In [3]: 2**2
    Out[3]: 4

    In [4]: 3.0 // 2.0
    Out[4]: 1.0

    In [5]: 3.0 % 2.0
    Out[5]: 1.0
  #+END_SRC

#+BEAMER: \pause
#+BEGIN_REMARK
En Python 2.X, la division entière pouvait se faire à l'aide de l'opérateur =/=
dès lors que des entiers étaient impliqués.

Python 3.X a introduit l'opérateur =//= pour lever toutes ambiguïtés.
#+END_REMARK

#+BEGIN_COMMENT
/cf./ cours
http://nbviewer.jupyter.org/github/jrjohansson/scientific-python-lectures/blob/master/Lecture-1-Introduction-to-Python-Programming.ipynb#Operators-and-comparisons

Attention à la division dans Python 3.X
#+END_COMMENT

** Opérations & comparaisons

- Opérations arithmétiques (suite) :  =+==, =-==, =*==, =/==, =%==, =**==

  #+BEGIN_SRC python
    In [1]: x = 1.0
    In [2]: x = x + 1.5
    In [3]: x += 1.5

    In [4]: i = 0
    In [5]: i += 1
  #+END_SRC

#+BEAMER: \pause
#+BEGIN_REMARK
Contrairement au C/C++, les opérateurs =++= et =--= n'existent pas en Python.
#+END_REMARK

** Opérations & comparaisons

- Opérations booléennes : =and=, =or= et =not=

  #+BEGIN_SRC python
    In [1]: True and False
    Out[1]: False

    In [2]: not False
    Out[2]: True

    In [3]: True or False
    Out[3]: True
  #+END_SRC

** Opérations & comparaisons

- Opérateur de comparaison : =>=, =<=, =>==, =<==, ====, =!==

  #+BEGIN_SRC python
    In [1]: 2 > 1, 2 < 1
    Out[1]: (True, False)

    In [2]: 2 > 2, 2 < 2
    Out[2]: (False, False)

    In [3]: 2 == 2
    Out[3]: True

    In [4]: 2 != 2
    Out[4]: False
  #+END_SRC

** Affectation multiples et parallèles

- Python autorise *l'affectation simultanée* d'une même valeur à plusieurs
  variables

  #+BEGIN_SRC python
    In [1]: x = y = 1.0

    In [2]: x, y
    Out[2]: (1.0, 1.0)
  #+END_SRC

  #+BEAMER: \pause

- Python permet également *l'affectation en parallèle* de plusieurs variables

  #+BEGIN_SRC python
    In [1]: x, y = 1.0, 1.0

    In [2]: x, y
    Out[2]: (1.0, 1.0)
  #+END_SRC

** Application : échange de deux valeurs

  #+BEGIN_SRC python
    In [1]: x, y = 1.0, 2.0

    In [2]: x, y
    Out[2]: (1.0, 2.0)

    In [3]: x, y = y, x

    In [4]: x, y
    Out[4]: (2.0, 1.0)
  #+END_SRC

** Mot-clés réservés

- Un certain nombre de mot-clés sont réservés au langage Python

  #+BEGIN_CENTER
  =and=, =as=, =assert=, =break=, =class=, =continue=, =def=, =del=, =elif=, =else=, =except=, =exec=,
  =finally=, =for=, =from=, =global=, =if=, =import=, =in=, =is=, *=lambda=*, =not=, =or=, =pass=,
  =print=, =raise=, =return=, =try=, =while=, =with=, *=yield=*
  #+END_CENTER

#+BEAMER: \pause

- Rien n'empêche en revanche, d'utiliser des noms de variables identiques à
  certaines fonctions du Python

  #+BEGIN_SRC python
    In [1]: type = 666
    In [2]: type(666)
    ---------------------------------------------------------------------------
    TypeError                                 Traceback (most recent call last)
    <ipython-input-2-7e2d10a8adcc> in <module>()
    ----> 1 type(666)

    TypeError: 'int' object is not callable
  #+END_SRC

** Structure conditionnelle

*** =if= python
:PROPERTIES:
:BEAMER_COL: 0.5
:END:
#+BEGIN_SRC python
  In [1]: test1 = False
     ...: test2 = False
     ...:
     ...: if test1:
     ...:     print("test1 est True")
     ...:
     ...: elif test2:
     ...:     print("test2 est True")
     ...:
     ...: else:
     ...:     print("test1 & test2 sont False")
#+END_SRC

*** Description
:PROPERTIES:
:BEAMER_COL: 0.6
:END:

#+ATTR_BEAMER: :overlay +-
- utilisation des mot-clés *=if/elif/else=*
- la fin de chaque condition est matérialisée par *le caractère =:=*
- *l'indentation (4 espaces ou une tabulation) délimite le bloc de condition*
- dans =ipython=, appuyer sur =Entrée= deux fois pour exécuter le bloc

** Structure conditionnelle

*** =if= python
:PROPERTIES:
:BEAMER_COL: 0.5
:END:
#+BEGIN_SRC python
  In [1]: test1 = False
     ...: test2 = False
     ...:
     ...: if test1:
     ...:     print("test1 est True")
     ...:
     ...: elif test2:
     ...:     print("test2 est True")
     ...:
     ...: else:
     ...:     print("test1 & test2 sont False")
#+END_SRC

*** =if= C/C++
:PROPERTIES:
:BEAMER_COL: 0.6
:END:
#+BEGIN_SRC C++
  bool test1 = false;
  bool test2 = false;

  if (test1)
    {
      cout << "test1 est True" << endl;
    }
   else if (test2)
     {
       cout << "test2 est True" << endl;
     }
   else
     {
       cout << "test1 & test2 sont False" << endl;
     }
#+END_SRC

** Structure conditionnelle

- Python offre la possibilité de former des /expressions/ dont l'évaluation est
  soumise à une condition

  #+BEGIN_SRC python
    In [1]: x = 2.0

    In [2]: y = x if x < 0 else x**2
    In [3]: y
    Out[3]: 4.0

    In [4]: print("y est positif" if y > 0 else "y est négatif")
    Out[4]: y est positif
  #+END_SRC

** Répétition conditionnelle

- Pour répéter un bloc d'instructions tant qu'une condition est réalisée, Python
  propose la clause *=while=*

- Suite de Syracuse

  #+BEGIN_SRC python
    In [3]: n = 27
    In [4]: while n != 1:
       ...:     if n % 2:
       ...:         n = 3*n+1
       ...:     else:
       ...:         n //= 2
       ...:     print(n, end=" ")
       ...:
    82 41 124 62 31 94 47 142 71 214 107 322 161 484 242 121 364 182 91 274 137 412 206 103
    310 155 466 233 700 350 175 526 263 790 395 1186 593 1780 890 445 1336 668 334 167 502
    251 754 377 1132 566 283 850 425 1276 638 319 958 479 1438 719 2158 1079 3238 1619 4858
    2429 7288 3644 1822 911 2734 1367 4102 2051 6154 3077 9232 4616 2308 1154 577 1732 866
    433 1300 650 325 976 488 244 122 61 184 92 46 23 70 35 106 53 160 80 40 20 10 5 16 8 4 2 1
  #+END_SRC

** Boucles =for=

- Pour répéter un certain nombre de fois un bloc d'instructions, on utilisera la
  construction suivante

  #+BEGIN_SRC python
    for variable in objet:
        bloc de commandes
  #+END_SRC

#+BEAMER: \pause

- Exemple :

  #+BEGIN_SRC python
    In [1]: for c in "abcdef":
       ...:     print(c)
       ...:
       a
       b
       c
       d
       e
       f
  #+END_SRC

** Boucles =for=

- Autres exemples:

  #+BEGIN_SRC python
    In [1]: for i in range(4):
       ...:     print(i)
       ...:
       0
       1
       2
       3
  #+END_SRC

  #+BEAMER: \pause \vskip15pt
  #+BEGIN_SRC python
    In [1]: for i in range(-4, 4, 2):
       ...:     print(i)
       ...:
       -4
       -2
       0
       2
  #+END_SRC

** Instructions =break= & =continue=

- Pour quitter une boucle =for= en cours d'exécution, on utilisera l'instruction
  *=break=*

  #+BEGIN_SRC python
    In [1]: for i in range(-4,4,2):
       ...:     if i == 0:
       ...:         break
       ...:     print(i)
       ...:
    -4
    -2
  #+END_SRC

#+BEAMER: \pause

- S'il s'agit de passer outre le bloc d'instruction suivant, on utilisera
  l'instruction *=continue=*

  #+BEGIN_SRC python
    In [1]: for i in range(-4,4,2):
       ...:     if i == 0:
       ...:         continue
       ...:     print(i)
       ...:
    -4
    -2
    2
  #+END_SRC

** Instructions =break= & =continue=

- S'il s'agit de passer outre le bloc d'instruction suivant, on utilisera
  l'instruction *=continue=*

  #+BEGIN_SRC python
    In [1]: for i in range(-4,4,2):
       ...:     if i == 0:
       ...:         continue
       ...:     print(i)
       ...:
    -4
    -2
    2
  #+END_SRC

  #+BEGIN_REMARK
  L'instruction =continue= est particulièrement utile afin d'éviter une trop grande
  imbrication d'instructions =if= successives.
  #+END_REMARK

* /Containers/ et autres fonctions
** Titre
:PROPERTIES:
:BEAMER_ENV: fullframe
:END:

#+BEGIN_EXPORT beamer
\title{\textit{Containers} et autres fonctions}
\titlepage
#+END_EXPORT

** Les séquences ou /containers/

- En plus des types fondamentaux (=int=, =float=,...), Python propose nativement un ensemble d'objets à
  accès séquentiel dont :
  - les chaînes de caractère
  - les listes & /tuples/
  - les dictionnaires

** Les chaînes de caractères

#+BEGIN_SRC python
  In [1]: citation = "Une noisette, j'la casse entre mes fesses tu vois... JCVD"

  In [2]: type(citation)
  Out[2]: str

  In [3]: len(citation)
  Out[3]: 57
#+END_SRC

#+BEGIN_REMARK
La fonction =len()= comme la fonction =type()= sont toutes deux des fonctions
intégrées au langage Python
#+END_REMARK

** Les chaînes de caractères
#+BEAMER: \framesubtitle{Apostrophe, guillemets \& triple guillemets}

#+ATTR_BEAMER: :overlay +-
- Chaîne de caractères délimitée par des guillemets
 #+BEGIN_SRC python
    In [1]: "Une noisette, j'la casse entre mes fesses tu vois... JCVD"
  #+END_SRC

- Chaîne de caractères délimitée par de simples apostrophes
 #+BEGIN_SRC python
   In [1]: 'Une noisette, j'la casse entre mes fesses tu vois... JCVD'
     File "<ipython-input-17-39c8b67fd376>", line 1
       'Une noisette, j'la casse entre mes fesses tu vois... JCVD'

   SyntaxError: invalid syntax
 #+END_SRC

 #+BEGIN_SRC python
   In [2]: 'Une noisette, j\'la casse entre mes fesses tu vois... JCVD'
 #+END_SRC

** Les chaînes de caractères
#+BEAMER: \framesubtitle{Apostrophe, guillemets \& triple guillemets}

- Chaîne de caractères délimitée par des guillemets
 #+BEGIN_SRC python
    In [1]: "Une noisette, j'la casse entre mes fesses tu vois... JCVD"
  #+END_SRC

- Chaîne de caractères délimitée par de simples apostrophes
 #+BEGIN_SRC python
   In [2]: 'Une noisette, j\'la casse entre mes fesses tu vois... JCVD'
 #+END_SRC

- Chaîne de caractères délimitée par des triples guillemets \to *documentation de
  fonctions*
 #+BEGIN_SRC python
   In [3]: """Une noisette,
   j'la casse entre mes fesses tu vois...
   JCVD"""
 #+END_SRC

** Les chaînes de caractères
#+BEAMER: \framesubtitle{Les méthodes associées}

- Les méthodes ou fonctions membres associées aux objets de type =str= sont
  accessibles par le biais de *l'opérateur =.=*

  #+BEAMER:\pause
  #+BEGIN_SRC python
    In [1]: question = "Qu'est-ce qu'un chat qui travaille à la SNCF ?"

    In [2]: question.upper()
    Out[2]: "QU'EST-CE QU'UN CHAT QUI TRAVAILLE À LA SNCF ?"
  #+END_SRC

  #+BEAMER:\pause\vskip-18pt
  #+BEGIN_SRC python
    In [3]: reponse = "un cheminou"

    In [4]: reponse.capitalize().center(20)
    Out[4]: '    Un cheminou     '

    In [5]: reponse.capitalize().center(20).strip()
    Out[5]: 'Un cheminou'
  #+END_SRC

#+BEAMER:\pause
- L'ensemble de ces méthodes sont accessibles /via/ l'aide en ligne de =ipython= /i.e./
  =help(str)= ou en usant de la complétion soit =reponse.<TAB>=

** Les chaînes de caractères
#+BEAMER: \framesubtitle{Parcours \& sélection de chaînes}

- Parcours par indice : =str[indice]=
  #+BEGIN_SRC python
    In [1]: citation = "Chuck Norris a déjà compté jusqu'à l'infini. Deux fois."

    In [2]: citation[0]
    Out[2]: 'C'

    In [3]: citation[2]
    Out[3]: 'u'

    In [4]: citation[-1]
    Out[4]: '.'
  #+END_SRC

** Les chaînes de caractères
#+BEAMER: \framesubtitle{Parcours \& sélection de chaînes}

- Sélection de sous-chaînes : =str[début:fin:pas]=
  #+BEGIN_SRC python
    In [1]: citation = "Chuck Norris a déjà compté jusqu'à l'infini. Deux fois."

    In [2]: citation[0:5]
    Out[2]: 'Chuck'

    In [3]: citation[2:4]
    Out[3]: 'uc'

    In [4]: citation[:5]
    Out[4]: 'Chuck'

    In [5]: citation[5:]
    Out[5]: " Norris a déjà compté jusqu'à l'infini. Deux fois."

    In [6]: citation[::2]
    Out[6]: "CukNri  éàcmt uq' 'nii exfi."

    In [7]: citation[::-1]
    Out[7]: ".siof xueD .inifni'l à'uqsuj étpmoc àjéd a sirroN kcuhC"
  #+END_SRC

** Les chaînes de caractères
#+BEAMER: \framesubtitle{Parcours \& sélection de chaînes}

- Remplacement de sous-chaînes :
  #+BEGIN_SRC python
    In [1]: citation = "Chuck Norris a déjà compté jusqu'à l'infini. Deux fois."

    In [2]: citation[6] = "D"
    ---------------------------------------------------------------------------
    TypeError                                 Traceback (most recent call last)
    <ipython-input-53-7080d03086cc> in <module>()
    ----> 1 citation[6] = "D"

    TypeError: 'str' object does not support item assignment
  #+END_SRC

  #+BEAMER: \pause
  #+BEGIN_REMARK
  Une chaîne de caractères est _un objet non /mutable/_ : on ne peut modifier
  l'objet qu'à la condition de créer une nouvelle référence en mémoire !
  #+END_REMARK

** Les chaînes de caractères
#+BEAMER: \framesubtitle{Parcours \& sélection de chaînes}

- Pour le remplacement de sous-chaînes, on tirera profit de la méthode =replace=
  associée aux méthodes =index= et =find=
  #+BEGIN_SRC python
    In [1]: citation = "Chuck Norris a déjà compté jusqu'à l'infini. Deux fois."
    In [2]: citation = citation.replace("Chuck Norris", "Patrick Puzo")
  #+END_SRC

** Les chaînes de caractères
#+BEAMER: \framesubtitle{Opérations logiques et arithmétiques}

#+ATTR_BEAMER: :overlay +-
- Vérification de présence :
  #+BEGIN_SRC python
    In [1]: citation = "Chuck Norris a déjà compté jusqu'à l'infini. Deux fois."
    In [2]: "Chuck" in citation
    Out[2]: True

    In [3]: "Patrick" not in citation
    Out[3]: True
  #+END_SRC

- Concaténation :
  #+BEGIN_SRC python
    In [1]: citation = "Chuck Norris a déjà compté jusqu'à l'infini. Deux fois."
    In [2]: citation + "Mais seulement " + str(1) + " fois jusqu'à moins l'infini."

    In [3]: citation*2
    Out[3]: "Chuck Norris a déjà [...].Chuck Norris a déjà [...]"
  #+END_SRC

** Les chaînes de caractères
#+BEAMER: \framesubtitle{Format et \emph{Formatage}}

- Utilisation des formats de données du C[fn:20089b4921487a8]
  #+BEGIN_SRC python
    In [1]: "Un entier: %i; un nombre flottant: %f; une chaîne : %s" % (1, 0.1, "toto")
    Out[1]: 'Un entier: 1; un nombre flottant: 0.100000; une chaîne : toto'

    In [2]: i = 2
    In [3]: filename = "processing_of_dataset_%03d.txt" % i
    In [4]: filename
    Out[4]: 'processing_of_dataset_002.txt'
  #+END_SRC

** Les chaînes de caractères
#+BEAMER: \framesubtitle{Format et \emph{Formatage}}

- Utilisation de la méthode =format=[fn:14f65e5336818de0]
  #+BEGIN_SRC python
    In [1]: canevas = "Nom: {}, prénom: {}, date de naissance: {}"

    In [2]: canevas.format("Van Rossum", "Guido", "31/01/1956")
    Out[2]: 'Nom: Van Rossum, prénom: Guido, date de naissance: 31/01/1956'
  #+END_SRC

  #+BEAMER:\pause
  #+BEGIN_SRC python
    In [1]: canevas = "L'année {0:d} s'écrit {0:b} en binaire et {0:x} en héxadécimal"

    In [2]: canevas.format(2017)
    Out[2]: "L'année 2017 s'écrit 11111100001 en binaire et 7e1 en héxadécimal"
  #+END_SRC

** Les listes
#+BEAMER: \framesubtitle{Initialisation d'une liste}

#+ATTR_BEAMER: :overlay +-
- Une liste est un objet qui permet de stocker *une collection d'objets de tous
  types*

- Initialisation d'une liste
  #+BEGIN_SRC python
    In [1]: l = []

    In [2]: l = ["rouge", "vert", "bleu", "noir"]

    In [3]: l = [1, 2, 3, 4]

    In [4]: l = [1, 2, "bleu", 3, 4]
    Out[4]: [1, 2, 'bleu', 3, 4]

    In [5]: type(l)
    Out[5]: list
  #+END_SRC

** Les listes
#+BEAMER: \framesubtitle{Initialisation d'une liste}

#+ATTR_BEAMER: :overlay +-
- Conversion en liste
  #+BEGIN_SRC python
    In [1]: l = list(range(4))
    In [2]: l
    Out[2]: [0, 1, 2, 3]

    In [3]: l = list("abcdef")
    In [4]: l
    Out[4]: ['a', 'b', 'c', 'd', 'e', 'f']
  #+END_SRC

- Initialisation d'une liste "en compréhension"
  #+BEGIN_SRC python
    In [1]: l = [x**2 for x in range(4)]
    In [2]: l
    Out[2]: [0, 1, 4, 9]

    In [3]: l = [x**2 for x in range(1,100) if x % 10 == 3]
    In [4]: l
    Out[4]: [9, 169, 529, 1089, 1849, 2809, 3969, 5329, 6889, 8649]
  #+END_SRC

** Les listes
#+BEAMER: \framesubtitle{Manipulation d'une liste}

- Accès par indice
  #+BEGIN_SRC python
    In [1]: kebab = ["salade", "tomates", "oignons", "sauce blanche"]

    In [2]: kebab[2]
    Out[2]: 'oignons'

    In [3]: kebab[-1]
    Out[3]: 'sauce blanche'
    In [4]: kebab[-2]
    Out[4]: 'oignons'

    In [5]: kebab[1:3]
    Out[5]: ['tomates', 'oignons']

    In [6]: kebab[0] = "sans salade"
    In [7]: kebab
    Out[7]: ['sans salade', 'tomates', 'oignons', 'sauce blanche']
  #+END_SRC

#+BEAMER: \pause
#+BEGIN_REMARK
À la différence des chaînes de caractères, les listes sont des objets _mutables_ !
#+END_REMARK

** Les listes
#+BEAMER: \framesubtitle{Manipulation d'une liste}

- Ajout & suppression d'éléments
  #+BEGIN_SRC python
    In [1]: kebab = ["salade", "tomates", "oignons", "sauce blanche"]

    In [2]: kebab.append("frites")
    In [3]: kebab
    Out[3]: ['salade', 'tomates', 'oignons', 'sauce blanche', 'frites']

    In [4]: kebab.pop()
    Out[4]: 'frites'
    In [5]: kebab
    Out[5]: ['salade', 'tomates', 'oignons', 'sauce blanche']

    In [6]: kebab.extend(['frites', 'coca'])
    In [7]: kebab
    Out[7]: ['salade', 'tomates', 'oignons', 'sauce blanche', 'frites', 'coca']

    In [8]: kebab.insert(3, "harissa")
    In [9]: kebab
    Out[9]: ['salade', 'tomates', 'oignons', 'harissa', 'sauce blanche', 'frites', 'coca']
  #+END_SRC

** Les listes
#+BEAMER: \framesubtitle{Manipulation d'une liste}

#+ATTR_BEAMER: :overlay +-
- Parcourir une liste
  #+BEGIN_SRC python
    In [1]: kebab = ["salade", "tomates", "oignons", "sauce blanche"]

    In [2]: for item in kebab:
       ...:     print(item)
    salade
    tomates
    oignons
    sauce blanche
  #+END_SRC

- Parcourir une liste en conservant l'indice
  #+BEGIN_SRC python
    In [1]: kebab = ["salade", "tomates", "oignons", "sauce blanche"]

    In [2]: for idx in range(0, len(kebab)):
       ...:     print(idx, kebab[idx])
    0 salade
    1 tomates
    2 oignons
    3 sauce blanche

    In [3]: for idx, item in enumerate(kebab):
       ...:     print(idx, item)
  #+END_SRC

** Les listes
#+BEAMER: \framesubtitle{Manipulation d'une liste}

- Tri de listes
  #+BEGIN_SRC python
    In [1]: kebab = ["salade", "tomates", "oignons", "sauce blanche"]

    In [2]: kebab.sort()
    In [3]: kebab
    Out[3]: ['oignons', 'salade', 'sauce blanche', 'tomates']

    In [4]: kebab.reverse()
    In [5]: kebab
    Out[5]: ['tomates', 'sauce blanche', 'salade', 'oignons']
  #+END_SRC

- Comme pour les chaînes de caractères, l'ensemble des méthodes associées aux
  objets de type =list= sont accessibles /via/ l'aide en ligne de =ipython= /i.e./
  =help(list)= ou en utilisant la complétion =kebab.<TAB>=

** Les dictionnaires

- Les dictionnaires sont des structures *mutables*, non ordonnées, formées
  d’enregistrements du type *=clé:valeur=*

- Le seul moyen d’accéder à une valeur particulière est par l’intermédiaire de
  sa clé

  #+BEGIN_SRC python
    In [1]: tel = {"emmanuelle": 5752, "sébastien": 5578}

    In [2]: tel["francis"] = 5915
    In [3]: tel
    Out[3]: {'sébastien': 5578, 'francis': 5915, 'emmanuelle': 5752}
    In [4]: tel["sébastien"]
    Out[4]: 5578

    In [5]: tel.keys()
    Out[5]: dict_keys(['emmanuelle', 'sébastien', 'francis'])

    In [6]: tel.values()
    Out[6]: dict_values([5752, 5578, 5915])

    In [7]: "francis" in tel
    Out[7]: True
  #+END_SRC

** Les dictionnaires

- Les dictionnaires sont des structures *mutables*, non ordonnées, formées
  d’enregistrements du type *=clé:valeur=*

- Le seul moyen d’accéder à une valeur particulière est par l’intermédiaire de
  sa clé

  #+BEGIN_SRC python
    In [1]: tel = {"emmanuelle": 5752, "sébastien": 5578, 'francis': 5915}

    In [2]: for key, value in tel.items():
       ...:     print("Clé/Valeur : {}/{}".format(key.capitalize(), value))

    Clé/Valeur : Emmanuelle/5752
    Clé/Valeur : Sébastien/5578
    Clé/Valeur : Francis/5915
  #+END_SRC

** Intermède /geek/

#+ATTR_LATEX: :width 0.65\linewidth
[[file:figures/ineffective_sorts.png]]

#+BEAMER:\scriptsize\hfill$^\dagger$
[[http://xkcd.com/1185/][xkcd comic]]

** Les fonctions

- Une fonction est *un bloc d’instructions* qui a reçu *un nom*
- Une fonction peut :
  1) dépendre d’un certain nombre de paramètres \to *les arguments*
  2) renvoyer un résultat au moyen de l’instruction *=return=*

#+BEAMER: \pause
- Quelques fonctions intégrées au langage Python
  - =help= : aide sur un nom \to =help(dict)=
  - =input= : entrée au clavier \to =n = int(input("N ?"))=
  - =print= : affiche à l'écran \to =print(n)=
  - =type=, =sum=, =range=, =min/max=, ...

** Les fonctions
#+BEAMER: \framesubtitle{Déclaration de fonctions}

- Fonction sans argument et sans valeur de retour
  #+BEGIN_SRC python
    In [1]: def dummy():
       ...:     print("Fonction 'dummy'")
       ...:

    In [2]: dummy()
    Fonction 'dummy'
  #+END_SRC

#+BEAMER: \pause
#+BEGIN_REMARK
Par défaut, la valeur de retour d'une fonction est =None=
#+END_REMARK

** Les fonctions
#+BEAMER: \framesubtitle{Déclaration de fonctions}

- Fonction *avec argument et valeur de retour*
  #+BEGIN_SRC python
    In [1]: def aire_disque(rayon):
       ...:     return 3.14 * rayon**2
       ...:

    In [2]: aire_disque(1.5)
    Out[2]: 7.065

    In [3]: aire_disque()
    ---------------------------------------------------------------------------
    TypeError                                 Traceback (most recent call last)
    <ipython-input-175-daee2592ca2a> in <module>()
    ----> 1 aire_disque()

    TypeError: aire_disque() missing 1 required positional argument: 'rayon'
  #+END_SRC

** Les fonctions
#+BEAMER: \framesubtitle{Déclaration de fonctions}

- Fonction *avec argument par défaut et valeur de retour*
  #+BEGIN_SRC python
    In [1]: def aire_disque(rayon=10.0):
       ...:     return 3.14 * rayon**2
       ...:

    In [2]: aire_disque(1.5)
    Out[2]: 7.065

    In [3]: aire_disque()
    Out[3]: 314.0

    In [4]: aire_disque(rayon=20)
    Out[4]: 1256.0
  #+END_SRC

** Les fonctions
#+BEAMER: \framesubtitle{Déclaration de fonctions}

- Fonction *retournant plusieurs valeurs*
  #+BEGIN_SRC python
    In [1]: def decomposer(entier, diviseur):
       ...:     return entier // diviseur, entier % diviseur
       ...:

    In [2]: partie_entiere, diviseur = decomposer(20,3)
    In [3]: partie_entiere, diviseur
    Out[3]: (6, 2)
  #+END_SRC

** Les fonctions
#+BEAMER: \framesubtitle{Fonctions $\lambda$}

- Les fonctions \lambda sont des fonctions dites *anonymes* /i.e./ sans nom
  pouvant être appliquée "à la volée" dans une expression

  #+BEAMER:\pause\vskip5pt
  #+BEGIN_SRC python
    In [1]: f = lambda x : x**2
    In [2]: f(2)
    Out[2]: 4

    In [3]: g = lambda x,y,z: 100*x+10*y+z
    In [4]: g(1,2,3)
    Out[4]: 123
  #+END_SRC

** Les fonctions
#+BEAMER: \framesubtitle{Documentation}

#+BEGIN_SRC python
  In [1]: def dummy():
     ...:     """Cette fonction ne sert strictement à rien.
     ...:
     ...:     En plus détaillé, cette fonction ne sert toujours
     ...:     à rien mais la description est plus longue.
     ...:     """

  In [2]: help(dummy)
      1 Help on function dummy in module __main__:
      2
      3 dummy()
      4     Cette fonction ne sert strictement à rien.
      5
      6     En plus détaillé, cette fonction ne sert toujours
      7     à rien mais la description est plus longue.
#+END_SRC

#+BEGIN_REMARK
Pour plus de détails sur les us et coutumes en matière de documentation /cf./
[[https://www.python.org/dev/peps/pep-0257/][/Docstrings conventions/]]
#+END_REMARK

** Les fonctions

- Les fonctions sont des objets ce qui implique qu'elles peuvent être :
  1) affectées à une variable
  2) un élément dans une séquence (liste, dictionnaires)
  3) passées comme argument à une autre fonction

  #+BEGIN_SRC python
    In [1]: ad = aire_disque

    In [2]: ad(2)
    Out[2]: 12.56

    In [3]: table = {"Calcul de l'aire d'un disque" : ad}
    In [4]: table["Calcul de l'aire d'un disque"]()
    Out[4]: 314.0

    In [5]: decomposer(ad(), 2)
    Out[5]: (157.0, 0.0)
  #+END_SRC

** Footnotes

[fn:20089b4921487a8] /cf./ [[https://en.wikipedia.org/wiki/Printf_format_string][C-style format]]

[fn:14f65e5336818de0] /cf./ [[https://docs.python.org/3/library/string.html#new-string-formatting][Python 3 string format]]
* Scripts/modules, entrées/sorties
** Titre
:PROPERTIES:
:BEAMER_ENV: fullframe
:END:

#+BEGIN_EXPORT beamer
\title{Scripts/modules, entrées/sorties}
\titlepage
#+END_EXPORT

** Scripts/modules

#+ATTR_BEAMER: :overlay +-
- Jusqu'à présent l'ensemble des commandes ou blocs d'instructions ont été tapé
  et testé directement dans l'interpréteur =ipython=

  - @@beamer:\color{green}\faThumbsUp@@ :: @@beamer:\color{green}@@ permet de
       tester en intéractif le code et sa validité
  - @@beamer:\color{red}\faThumbsDown@@ :: @@beamer:\color{red}@@ rend difficile
       la réutilisation et la modification du code

- Plus la problématique deviendra compliquée, plus le besoin d'écrire du code
  dans un ou des fichiers, *scripts ou modules*, deviendra pertinente (test,
  maintenance, lecture du code...)

** Scripts =python=

- *Un script* est un fichier contenant un ensemble d'instructions =python=

- L'extension du fichier-script sera *=.py=* (indentation, coloration
  syntaxique...)

- Exemple =citation.py=
 #+BEGIN_SRC python -n
   citation = "Une noisette, j'la casse entre mes fesses tu vois... JCVD"
   for word in citation.split():
       print(word)
 #+END_SRC

** Scripts =python=

- Le script peut être lancé depuis le terminal /via/ la commande
  #+BEGIN_SRC python
    $ python citation.py
  #+END_SRC

  ou directement dans l'interpréteur =ipython= en faisant
  #+BEGIN_SRC python
    In [1]: %run citation.py

    In [2]: citation
    Out[2]: "Une noisette, j'la casse entre mes fesses tu vois... JCVD"
  #+END_SRC

** Modules =python=

- À la différence d'un script, *un module =python=* est un fichier contenant un
  *ensemble de fonctions* pouvant être utilisées par différents scripts

- Exemple =jcvd_collection.py=
  #+BEGIN_SRC python -n :tangle /tmp/jcvd_collection.py
    """
       A file with a lot of JCVD inside

       This module holds several quotes from Jean-Claude Van Damme
    """

    def quote0():
        print("Une noisette, j'la casse entre mes fesses tu vois...")

    def quote1():
        print("Quand tu prends confiance en la confiance tu deviens confiant.")

    def quote2():
        print("Ce n'est pas moi qui parle...c'est nous qui parlons.")
  #+END_SRC

** Modules =python=

- Pour pouvoir utiliser le module et ses fonctions, *il est nécessaire de
  l'importer* soit dans un script ou soit dans l'interpréteur
  #+ATTR_BEAMER: :overlay +-
  1) Importation de base
     #+BEGIN_SRC python
       In [1]: import jcvd_collection
       In [2]: jcvd_collection.quote1()
       Quand tu prends confiance en la confiance tu deviens confiant.
     #+END_SRC
     #+BEAMER:\vskip5pt

  2) Importation à l'aide d'un nom raccourci
     #+BEGIN_SRC python
       In [1]: import jcvd_collection as jcvd
       In [2]: jcvd.quote1()
       Quand tu prends confiance en la confiance tu deviens confiant.
     #+END_SRC
     #+BEAMER:\vskip5pt

  3) Importation spécifique d'une fonction
     #+BEGIN_SRC python
       In [1]: from jcvd_collection import quote1
       In [2]: quote1()
       Quand tu prends confiance en la confiance tu deviens confiant.
     #+END_SRC

** Modules =python=

- La fonction =help= permet d'accéder à la documentation du module
  #+BEGIN_SRC python
    In [1]: help(jcvd_collection)
  #+END_SRC

#+BEAMER: \pause

- Par défaut, la localisation des modules se fait dans différents répertoires
  #+ATTR_BEAMER: :overlay +-
  1) dans le répertoire local
  2) dans les répertoires définis au sein de la variable d'environnement
     =PYTHONPATH=
  3) dans l'ensemble des répertoires référencés par =sys.path=
     #+BEGIN_SRC python
       In [1]: import sys
       In [2]: sys.path
       ['',
        '/home/garrido/Development/python.d/ipython/bin',
        '/usr/lib/python36.zip',
        '/usr/lib/python3.6',
        '/usr/lib/python3.6/lib-dynload',
        '/home/garrido/Development/python.d/ipython/lib/python3.6/site-packages',
        '/home/garrido/Development/python.d/ipython/lib/python3.6/site-packages/IPython/extensions',
        '/home/garrido/.ipython']
  #+END_SRC

** Entrées/sorties

- La fonction intégrée *=print=* permet d'afficher à l'écran n'importe quelle chaîne
  de caractères
  #+BEGIN_SRC python
    In [1]: print("Qu'est qu'un chat qui voit dans le futur ?")
  #+END_SRC

#+BEAMER: \pause

- La fonction intégrée *=input=* permet de récupérer une saisie clavier sous la
  forme d'une chaîne de caractères
  #+BEGIN_SRC python
    In [2]: reponse = input("Réponse ? ")
  #+END_SRC

** Entrées/sorties

- L'écriture dans un fichier se fait nécessairement par le biais de chaîne de
  caractères
  #+BEGIN_SRC python
    In [1]: f = open("QA.txt", "w")
    In [2]: f.write("Qu'est qu'un chat qui voit dans le futur ?")
    In [3]: f.close()
  #+END_SRC

** Entrées/sorties

- La lecture dans un fichier peut se faire de la façon suivante...
  #+BEGIN_SRC python
    In [1]: f = open("QA.txt", "r")
    In [2]: s = f.read()
    In [3]: print(s)
    Qu'est qu'un chat qui voit dans le futur ?
    In [4]: f.close()
  #+END_SRC

#+BEAMER: \pause

- ...ou en lisant le fichier ligne par ligne
  #+BEGIN_SRC python
    In [1]: with open("QA.txt", "r") as f:
       ...:     for line in f:
       ...:         print(line)
       ...:
  #+END_SRC

  L'instruction =with= assure que le fichier sera fermé quoiqu'il advienne
  notamment si une exception est levée
