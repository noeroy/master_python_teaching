#+OPTIONS: toc:nil ^:{} H:2 author:nil
#+STARTUP:     beamer
#+LATEX_CLASS: python-slide

* Librairie =numpy=
** Titre
:PROPERTIES:
:BEAMER_ENV: fullframe
:END:

#+BEGIN_EXPORT beamer
\title{\texttt{numpy} : librairie pour le calcul scientifique}
\titlepage
#+END_EXPORT

** =numpy= ?

- Le module =numpy= est l'outil de base utilisé dans tous calculs scientifiques et
  donc numériques en Python

- =numpy= fournit en particulier des objets de type *vecteurs, matrices et plus
  généralement tableaux à $n$ dimensions*

- =numpy= facilite et *optimise[fn:e0eb780c73d6562]* les opérations de *stockage et
  de manipulation* des données *numériques* notamment lorsque la taille des
  tableaux devient importante \to /array oriented computing/

** Importation & documentation =numpy=

- Convention d'importation
  #+BEGIN_SRC python
    In [1]: import numpy as np
  #+END_SRC

- Documentation de référence du module http://docs.scipy.org/

- Aide interactive

  #+BEGIN_SRC python
    In [1]: np.array?
         1 Docstring:
         2 array(object, dtype=None, copy=True, order=None, subok=False, ndmin=0)
         3
         4 Create an array.
         5 ...
  #+END_SRC

  #+BEAMER: \pause\vskip-18pt
  #+BEGIN_SRC python
    In [2]: np.lookfor("create array")
         1 Search results for 'create array'
         2 ---------------------------------
         3 numpy.array
         4     Create an array.
         5 numpy.memmap
         6     Create a memory-map to an array stored in a *binary* file on disk.
  #+END_SRC

** Création de vecteurs, matrices

- À partir d'une liste de valeurs
  - Vecteur
    #+BEGIN_SRC python
      In [2]: v = np.array([0, 1, 2, 3])
      In [3]: v
      Out[3]: array([0, 1, 2, 3])
    #+END_SRC
    #+BEAMER: \pause

  - Matrice 2\times2
    #+BEGIN_SRC python
      In [4]: M = np.array([[0, 1], [2, 3]])
      In [5]: M
      Out[5]:
      array([[0, 1],
             [2, 3]])
    #+END_SRC

    #+BEAMER: \pause\vskip-18pt
    #+BEGIN_SRC python
      In [6]: type(v), type(M)
      Out[6]: (numpy.ndarray, numpy.ndarray)

      In [7]: v.ndim, M.ndim
      Out[7]: (1, 2)

      In [8]: v.shape, M.shape
      Out[8]: ((4,), (2, 2))
    #+END_SRC

** Pourquoi =numpy= ?

- Les objets de type =numpy.ndarray= \equiv à une liste Python (ou liste de
  listes)

- *Pourquoi ne pas simplement utiliser les listes Python pour les calculs au
  lieu de créer un nouveau type de tableau ?*

** Pourquoi =numpy= ?

Il existe plusieurs (très bonnes) raisons à cela:

#+ATTR_BEAMER: :overlay +-
- Les listes Python sont très générales (on parle également d'objet de haut
  niveau). *Elles peuvent contenir n'importe quel objet \to typage
  dynamique*. Elles ne supportent pas les opérations mathématiques.

- Les tableaux ou /array/ de =numpy= sont *statiquement typées et homogènes[fn:ea2b86f523276c9]*

  - Le type des éléments est déterminé lorsque le tableau est créé *\to plus de
    typage dynamique*
  - De même la taille du tableau est fixée à la création *\to stockage en
    mémoire optimisée*

- En raison du typage statique, les fonctions mathématiques telles que la
  multiplication et l'addition de matrices peuvent être mises en œuvre /via/ un
  langage compilé (C et Fortran)

#+BEGIN_COMMENT
So far the numpy.ndarray looks awefully much like a Python list (or nested
list). Why not simply use Python lists for computations instead of creating a
new array type?

There are several reasons:

- Python lists are very general. They can contain any kind of object. They are
  dynamically typed. They do not support mathematical functions such as matrix
  and dot multiplications, etc. Implementing such functions for Python lists
  would not be very efficient because of the dynamic typing.
- Numpy arrays are statically typed and homogeneous. The type of the elements is
  determined when the array is created.
- Numpy arrays are memory efficient.
- Because of the static typing, fast implementation of mathematical functions
  such as multiplication and addition of numpy arrays can be implemented in a
  compiled language (C and Fortran is used).

http://nbviewer.jupyter.org/github/jrjohansson/scientific-python-lectures/blob/master/Lecture-2-Numpy.ipynb#From-lists

http://www.scipy-lectures.org/intro/numpy/array_object.html#numpy-arrays

#+END_COMMENT

** Pourquoi =numpy= ?

- Démonstration
  #+BEAMER: \vskip5pt
  #+BEGIN_SRC python
    In [1]: %timeit [i**2 for i in range(1000)]
    1000 loops, best of 3: 403 us per loop
  #+END_SRC

  #+BEAMER: \pause\vskip5pt
  #+BEGIN_SRC python
    In [3]: a = np.arange(1000)
    In [4]: %timeit a**2
    100000 loops, best of 3: 12.7 us per loop
  #+END_SRC

** COMMENT Création de tableau (suite)

#+ATTR_BEAMER: :overlay +-
- Le type de données numériques est défini à la création du tableau

- Vecteur d'entiers
  #+BEAMER: \vskip5pt
  #+BEGIN_SRC python
    In [1]: v = np.array([0, 1, 2, 3])
    In [2]: v
    Out[2]: array([0, 1, 2, 3])

    In [3]: v.dtype
    Out[3]: dtype('int64')
  #+END_SRC

- Vecteur de nombres flottants
  #+BEAMER: \vskip5pt
  #+BEGIN_SRC python
    In [1]: v = np.array([0., 1., 2., 3.])
    In [2]: v.dtype
    Out[2]: dtype('float64')
  #+END_SRC

- ou en forçant le type de données \footnotesize(=float=, =int=, =bool=, 16, 32, 64 bits)
  #+BEAMER: \vskip5pt
  #+BEGIN_SRC python
    In [1]: v = np.array([0, 1, 2, 3], dtype=np.float)
    In [2]: v.dtype
    Out[2]: dtype('float64')
  #+END_SRC

** Création de tableau (suite)

Dans la pratique, les valeurs d'un tableau sont rarement saisies une par une

#+ATTR_BEAMER: :overlay +-
- Fonction =arange= \equiv =range=
  #+BEAMER: \vskip5pt
  #+BEGIN_SRC python
    In [1]: np.arange(10)
    Out[1]: array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])

    In [2]: np.arange(0, 10, step=2)
    Out[2]: array([0, 2, 4, 6, 8])
  #+END_SRC
  #+BEAMER: \vskip5pt

- Fonctions =linspace/logspace=
  #+BEAMER: \vskip5pt
  #+BEGIN_SRC python
    In [1]: np.linspace(0, 10, num=5)
    Out[1: array([  0. ,   2.5,   5. ,   7.5,  10. ])

    In [2]: np.logspace(0, 10, num=5)
    Out[2]:
    array([  1.00000000e+00,   3.16227766e+02,   1.00000000e+05,
             3.16227766e+07,   1.00000000e+10])
  #+END_SRC

** Création de tableau (suite)

#+ATTR_BEAMER: :overlay +-
- Vecteurs, matrices avec valeurs par défaut

  #+BEGIN_SRC python
    In [1]: np.zeros(10)
    Out[1]: array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0])

    In [2]: np.ones(shape=(3,3))
    Out[2]:
    array([[ 1.,  1.,  1.],
           [ 1.,  1.,  1.],
           [ 1.,  1.,  1.]])

    In [3]: np.full((3,3), 666, dtype=np.int)
    Out[3]:
    array([[666, 666, 666],
           [666, 666, 666],
           [666, 666, 666]])

    In [4]: np.eye((3,3))
    Out[4]:
    array([[ 1.,  0.,  0.],
           [ 0.,  1.,  0.],
           [ 0.,  0.,  1.]])
  #+END_SRC

** Création de tableau (suite)

- Générateurs aléatoires =rand/randint/randn=

  #+BEGIN_SRC python
    In [1]: np.random.rand(3)
    Out[1]: array([ 0.21401051,  0.19514481,  0.92647823])

    In [2]: np.random.randint(0, 10, 3)
    Out[2]: array([8, 8, 3])

    In [3]: np.random.randn(3)
    Out[3]: array([-0.4829445 , -1.05459848, -1.30539831])
  #+END_SRC

  #+BEAMER: \pause
  #+BEGIN_REMARK
  Un générateur aléatoire n'est par définition pas aléatoire dans une machine
  déterministe qu'est un ordinateur !

  #+BEGIN_SRC python
    In [1]: np.random.seed(1234)
  #+END_SRC
  #+END_REMARK

** Création de tableau : intermède graphique
*** Python code
:PROPERTIES:
:BEAMER_COL: 0.5
:END:

#+BEGIN_SRC python
  In [1]: import numpy as np
  In [2]: import matplotlib.pyplot as plt
  In [3]: %matplotlib

  In [4]: img = np.random.randn(30, 30)
  In [5]: plt.imshow(img, cmap=plt.cm.hot,
                     extent=(0,30,0,30))
  In [6]: plt.colorbar()
#+END_SRC

*** Color map
:PROPERTIES:
:BEAMER_COL: 0.5
:END:

#+ATTR_LATEX: :width 1.2\linewidth
[[file:figures/cmap.pdf]]

** Parcours par indice

#+ATTR_BEAMER: :overlay +-
- L'utilisation de l'opérateur =[]= est similaire à celle des listes
  #+BEGIN_SRC python
    In [1]: x = np.random.randint(10, size=5)
    In [2]: x
    Out[2]: array([8, 0, 1, 6, 0])

    In [3]: x[0], x[3], x[-1]
    Out[3]: (8, 6, 0)
  #+END_SRC

- Pour les tableaux à $n$ dimensions
  #+BEGIN_SRC python
    In [1]: x = np.random.randint(10, size=(3, 4))
    In [2]: x
    Out[2]:
    array([[8, 3, 6, 4],
           [9, 8, 2, 0],
           [0, 5, 5, 4]])

    In [3]: x[0, 0], x[2, 0], x[2, -1]
    Out[3]: (8, 0, 4)
  #+END_SRC

** Parcours par indice

- Comme pour les listes qui sont des objets /mutables/, il est possible d'assigner
  une valeur en spécifiant l'indice

  #+BEGIN_SRC python
    In [4]: x[0, 0] = 12
    In [5]: x
    Out[5]:
    array([[12, 3, 6, 4],
           [ 9, 8, 2, 0],
           [ 0, 5, 5, 4]])
  #+END_SRC

#+BEAMER: \pause
#+BEGIN_REMARK
Le type de données numériques stockées est fixé à la création du tableau

#+BEGIN_SRC python
  In [6]: x[0, 0] = 3.1415
  In [7]: x
  Out[7]:
  array([[3, 3, 6, 4],
         [9, 8, 2, 0],
         [0, 5, 5, 4]])
#+END_SRC
#+END_REMARK

** Sélection par indice

- Comme pour les listes, il est possible d'utiliser la syntaxe =[start:stop:step]=
  pour sélectionner un sous espace vectoriel

  #+BEGIN_SRC python
    In [1]: x
    Out[1]:
    array([[3, 3, 6, 4],
           [9, 8, 2, 0],
           [0, 5, 5, 4]])
  #+END_SRC

  #+ATTR_BEAMER: :overlay +-
  - Sélection d'une ligne

    #+BEGIN_SRC python
      In [2]: x[0]
      Out[2]: array([[3, 3, 6, 4])
    #+END_SRC

  - *Sélection d'une colonne*

    #+BEGIN_SRC python
      In [2]: x[:, 0], x[:, 1]
      Out[2]: (array([3, 9, 0]), array([3, 8, 5]))
    #+END_SRC

** Sélection par indice

- À la différence des listes, les sous espaces vectoriels sélectionnés ne sont
  pas des copies mais *une vue réduite* de la matrice globale

- Toute modification opérée sur le sous espace vectoriel est reportée dans la
  matrice globale
  #+BEAMER: \pause
  #+BEGIN_SRC python
    In [1]: x
    Out[1]:
    array([[3, 3, 6, 4],
           [9, 8, 2, 0],
           [0, 5, 5, 4]])

    In [2]: xx = x[:2, :2]
    In [3]: xx
    Out[3]:
    array([[3, 3],
           [9, 8]])

    In [4]: xx[0, 0] = 0
    In [5]: x
    Out[5]:
    array([[0, 3, 6, 4],
           [9, 8, 2, 0],
           [0, 5, 5, 4]])
  #+END_SRC

** Sélection par indice

- Pour réaliser une copie d'un sous espace vectoriel, on utilisera la méthode =copy()=

  #+BEGIN_SRC python
    In [2]: xx = x[:2, :2].copy()
    In [3]: xx
    Out[3]:
    array([[0, 3],
           [9, 8]])

    In [4]: xx[0, 0] = 666
    In [5]: x
    Out[5]:
    array([[0, 3, 6, 4],
           [9, 8, 2, 0],
           [0, 5, 5, 4]])
  #+END_SRC

** Opérations mathématiques

- *Grâce à l'homogénéité des tableaux de =numpy=*, il est possible de réaliser des
  opérations mathématiques \neq listes Python

  #+BEGIN_SRC python
    In [1]: l = [1, 2, 3, 4]
    In [2]: l+5
    ---------------------------------------------------------------------------
    TypeError                                 Traceback (most recent call last)
    <ipython-input-53-1cb32c2d071d> in <module>()
    ----> 1 l+5

    TypeError: can only concatenate list (not "int") to list
  #+END_SRC

** Opérations mathématiques

- *Grâce à l'homogénéité des tableaux de =numpy=*, il est possible de réaliser des
  opérations mathématiques

- Opérateurs binaires
  #+BEGIN_SRC python
    In [1]: x = np.arange(4)
    In [2]: x
    Out[2]: array([0, 1, 2, 3])

    In [3]: x+5
    Out[3]: array([5, 6, 7, 8])

    In [4]: x-5
    Out[4]: array([-5, -4, -3, -2])

    In [5]: x*5
    Out[5]: array([ 0,  5, 10, 15])

    In [5]: x/5
    Out[5]: array([ 0. ,  0.2,  0.4,  0.6]))
  #+END_SRC

** Opérations mathématiques

- *Grâce à l'homogénéité des tableaux de =numpy=*, il est possible de réaliser des
  opérations mathématiques

- Opérateurs unaires
  #+BEGIN_SRC python
    In [1]: x = np.arange(4)

    In [2]: -x
    Out[2]: array([0, -1, -2, -3])

    In [3]: x**2
    Out[3]: array([0, 1, 4, 9])

    In [4]: x%2
    Out[4]: array([0, 1, 0, 1])
  #+END_SRC

** Opérations mathématiques

#+ATTR_BEAMER: :overlay +-
- En plus des opérateurs usuels, =numpy= fournit un ensemble de *fonctions dites
  universelles* (ou /ufuncs/) opérant sur des tableaux

- Fonctions trigonométriques
  #+BEGIN_SRC python
    In [1]: theta = np.linspace(0, np.pi, 3)

    In [2]: np.cos(theta)
    Out[2]: array([  1.00000000e+00,   6.12323400e-17,  -1.00000000e+00])

    In [3]: np.sin(theta)
    Out[3]: array([  0.00000000e+00,   1.00000000e+00,   1.22464680e-16])

    In [4]: np.tan(theta)
    Out[4]: array([  0.00000000e+00,   1.63312394e+16,  -1.22464680e-16])
  #+END_SRC

- Autres fonctions : =np.exp(), np.power(), np.log(), np.log10(),...=

** Opérations statistiques

#+ATTR_BEAMER: :overlay +-
- Somme des éléments d'un tableau

  #+BEGIN_SRC python
    In [1]: x = np.random.rand(100)

    In [2]: sum(x)
    Out[2]: 50.394482884150314

    In [3]: np.sum(x)
    Out[3]: 50.394482884150314
  #+END_SRC

- Toutefois, la formulation =np.sum()= propre à =numpy= présente l'avantage d'être
  nettement plus rapide (code compilé) en plus d'être plus générale

  #+BEGIN_SRC python
    In [4]: big_array = np.random.rand(1000000)

    In [5]: %timeit sum(big_array)
    10 loops, best of 3: 82.9 ms per loop

    In [6]: %timeit np.sum(big_array)
    1000 loops, best of 3: 467 µs per loop
  #+END_SRC

** COMMENT Opérations statistiques

#+ATTR_BEAMER: :overlay +-
- Somme des éléments d'un tableau : méthode =sum=
  #+BEAMER: \vskip5pt
  #+BEGIN_SRC python
    In [1]: M = np.random.randint(10, (3, 4))
    In [2]: M
    Out[2]:
    array([[7, 0, 8, 4],
           [4, 7, 0, 5],
           [7, 0, 7, 6]])

    In [3]: np.sum(M), M.sum()
    Out[3]: (55, 55)
  #+END_SRC
  #+BEAMER: \vskip5pt

- Somme colonne par colonne
  #+BEAMER: \vskip5pt
  #+BEGIN_SRC python
    In [4]: M.sum(axis=0)
    Out[4]: array([18,  7, 15, 15])
  #+END_SRC
  #+BEAMER: \vskip5pt

- Somme ligne par ligne
  #+BEAMER: \vskip5pt
  #+BEGIN_SRC python
    In [5]: M.sum(axis=1)
    Out[5]: array([19, 16, 20])
  #+END_SRC

** Opérations statistiques

|---------------+-------------------------------------------|
| Fonction      | Description                               |
| =np.sum=        | Somme des éléments                        |
| =np.prod=       | Produit des éléments                      |
| =np.mean=       | Valeur moyenne                            |
| =np.std=        | Standard déviation                        |
| =np.var=        | Variance                                  |
| =np.min=        | Valeur minimale                           |
| =np.max=        | Valeur maximale                           |
| =np.argmin=     | Indice de la valeur minimale              |
| =np.argmax=     | Indice de la valeur maximale              |
| =np.median=     | Valeur médiane                            |
| =np.percentile= | Quantiles                                 |
|---------------+-------------------------------------------|

** Opérations algébriques

- Multiplication de matrices
  #+BEGIN_SRC python
    In [1]: M = np.ones(shape=(3,3))
    In [2]: M
    Out[2]:
    array([[ 1.,  1.,  1.],
           [ 1.,  1.,  1.],
           [ 1.,  1.,  1.]])

    In [3]: M*M
    Out[3]:
    array([[ 1.,  1.,  1.],
           [ 1.,  1.,  1.],
           [ 1.,  1.,  1.]])

    In [4]: M.dot(M)
    Out[4]:
    array([[ 3.,  3.,  3.],
           [ 3.,  3.,  3.],
           [ 3.,  3.,  3.]])
  #+END_SRC

** Opérations algébriques

- Transposition de matrices
  #+BEGIN_SRC python
    In [1]: M = np.random.randint(5, size=(3,3))
    In [2]: M
    Out[2]:
    array([[4, 1, 0],
           [2, 3, 0],
           [1, 0, 2]])

    In [3]: M.transpose()
    Out[3]:
    array([[4, 2, 1],
           [1, 3, 0],
           [0, 0, 2]])
  #+END_SRC

** Opérations algébriques

- Conversion d'un vecteur vers une matrice

  #+BEGIN_SRC python
    In [1]: v = np.arange(4)
    In [2]: v
    Out[2]: array([0, 1, 2, 3])

    In [3]: v[:, np.newaxis]
    Out[3]:
    array([[0],
           [1],
           [2],
           [3]])
  #+END_SRC

** Opérations algébriques : intermède graphique

#+BEGIN_SRC latex
  \begin{align*}
    z = f(x,y) =& \sin^{10} x + \cos(x\cdot y)\cdot\cos x\\
    =&\sin^{10}\begin{bmatrix}
    x_0&\cdots
    \end{bmatrix}+\cos\left(\begin{bmatrix}
        x_0&\cdots
      \end{bmatrix}\cdot\begin{bmatrix}
    y_0\\\vdots\end{bmatrix}\right)\cdot\cos\begin{bmatrix}
        x_0&\cdots
      \end{bmatrix}
  \end{align*}
#+END_SRC

#+BEAMER: \vskip-20pt\pause

*** Python code
:PROPERTIES:
:BEAMER_COL: 0.55
:END:

#+BEGIN_SRC python
  In [1]: import numpy as np
  In [2]: import matplotlib.pyplot as plt
  In [3]: %matplotlib

  In [4]: x = np.linspace(0, 5, 500)
  In [5]: y = np.linspace(0, 5, 500)[:, np.newaxis]
  In [6]: z = np.sin(x)**10 + np.cos(x*y)*np.cos(x)
  In [7]: x.shape, y.shape, z.shape
  Out[7]: ((500,), (500, 1), (500, 500))

  In [8]: plt.imshow(z, extent=[0, 5, 0, 5],
                     cmap="viridis")
  In [9]: plt.colorbar();
#+END_SRC

*** Color map
:PROPERTIES:
:BEAMER_COL: 0.55
:END:

#+BEAMER: \visible<2>{
#+ATTR_LATEX: :width 1.1\linewidth
[[file:figures/zxy.pdf]]
#+BEAMER: }

** Opérations logiques

- En plus des opérateurs et fonctions mathématiques, =numpy= fournit également les
  opérateurs de comparaison opérant sur les éléments d'un tableau
  #+BEGIN_SRC python
    In [1]: x = np.array([1, 2, 3, 4, 5])

    In [2]: x < 3
    Out[2]: array([ True,  True, False, False, False], dtype=bool)

    In [3]: x == 3
    Out[3]: array([False, False,  True, False, False], dtype=bool)

    In [4]: (x * 2) == (x**2)
    Out[4]: array([False,  True, False, False, False], dtype=bool)
  #+END_SRC

** COMMENT Opérations logiques

- =numpy= fournit également les méthodes =any= et =all=
  #+BEAMER: \vskip5pt
  #+BEGIN_SRC python
    In [5]: np.any(x > 10)
    Out[5]: False

    In [6]: np.all(x < 10)
    Out[6]: True
  #+END_SRC

** Opérations logiques

- Il est finalement possible de dénombrer le nombre de valeurs d'un tableau
  satisfaisant à une ou des conditions
  #+BEAMER: \vskip5pt
  #+BEGIN_SRC python
    In [7]: np.sum(x > 3)
    Out[7]: 2

    In [8]: np.sum((x > 3) & (x < 5))
    Out[8]: 1
  #+END_SRC

** Sélection par masque

- Les opérations de comparaison sur des tableaux retournent un tableau de
  booléens qui peut servir à la sélection d'éléments du tableau
  #+BEGIN_SRC python
    In [1]: x = np.random.randint(0, 10, 10)
    In [2]: x
    Out[2]: array([8, 9, 6, 2, 4, 5, 9, 4, 0, 7])

    In [3]: x < 5
    Out[3]: array([False, False, False,  True,  True, False, False,  True,  True, False], dtype=bool)

    In [4]: x[x < 5]
    Out[4]: array([2, 4, 4, 0])
  #+END_SRC

** Sélection par masque : intermède graphique
*** Python code
:PROPERTIES:
:BEAMER_COL: 0.55
:END:

#+BEGIN_SRC python
  In [1]: import numpy as np
  In [2]: import matplotlib.pyplot as plt
  In [3]: %matplotlib

  In [4]: x = np.random.rand(1000)
  In [5]: y = np.random.rand(1000)
  In [6]: plt.scatter(x, y, alpha=0.3)
  In [7]: plt.axis("scaled"); plt.axis([0, 1, 0, 1])

  In [8]: mask = (x*y > 0.5)
  In [9]: plt.scatter(x[mask], y[mask], alpha=0.6,
                      edgecolors="orange", c="none",
                      s=200)
#+END_SRC

*** Mask
:PROPERTIES:
:BEAMER_COL: 0.55
:END:

#+ATTR_LATEX: :width 1.1\linewidth
[[file:figures/mask.pdf]]

** Entrées/sorties de =numpy=

- =numpy= permet de charger un fichier texte dans un objet de type =ndarray=
  #+BEGIN_SRC python
    In [1]: cat /tmp/results.tsv
    # id        OPP    MQ1     MA
    21606456   9.90  12.32  16.00
    21402354  11.20  10.50  12.25

    In [2]: results = np.loadtxt("/tmp/results.tsv")
    In [3]: results
    Out[3]:
    array([[  2.16064560e+07,   9.90000000e+00,   1.23200000e+01,
              1.60000000e+01],
           [  2.14023540e+07,   1.12000000e+01,   1.05000000e+01,
              1.22500000e+01]])
  #+END_SRC

** Entrées/sorties de =numpy=

#+ATTR_BEAMER: :overlay +-
- =numpy= permet également de sauvegarder un tableau dans un fichier texte
  #+BEGIN_SRC python
    In [4]: np.savetxt("/tmp/results2.tsv", results)
  #+END_SRC

- le module [[http://pandas.pydata.org/][=pandas=]] est toutefois bien mieux adapté à la lecture de fichier
  contenant des données numériques

** Footnotes

[fn:e0eb780c73d6562] les principales fonctions de =numpy= sont implémentées en C
et en Fortran

[fn:ea2b86f523276c9] pour plus de détails, /cf./ [[http://nbviewer.jupyter.org/github/jakevdp/PythonDataScienceHandbook/blob/master/notebooks/02.01-Understanding-Data-Types.ipynb#Understanding-Data-Types-in-Python][discussion]]

[fn:1c1516c060af0c15] pour plus de détails, /cf./ [[http://nbviewer.jupyter.org/github/jakevdp/PythonDataScienceHandbook/blob/master/notebooks/02.05-Computation-on-arrays-broadcasting.ipynb#Computation-on-Arrays:-Broadcasting][discussion]]

** COMMENT Annexes
:PROPERTIES:
:BEAMER_OPT: plain
:BEAMER_ENV: fullframe
:END:

#+BEAMER: \partpage

** COMMENT Opérations algébriques : /Broadcasting/[fn:1c1516c060af0c15]

#+ATTR_LATEX: :width 0.7\linewidth
[[file:figures/broadcast.pdf]]

* Librairie =matplotlib=
** Titre
:PROPERTIES:
:BEAMER_ENV: fullframe
:END:

#+BEGIN_EXPORT beamer
\title{\texttt{matplotlib} : librairie pour la représentation graphique}
\titlepage
#+END_EXPORT

** =matplotlib= ?

#+ATTR_BEAMER: :overlay +-
- La librairie =matplotlib= est *la* bibliothèque graphique de Python

- Étroitement liée à =numpy= et =scipy=

- Grande variété de *format de sortie (=png=, =pdf=, =svg=, =eps=, =pgf=)*
  ainsi que support de *\LaTeX* pour le texte

- /Graphical User Interface/ pour l'exploration interactive des figures (zoom,
  sélection,...)

- Tous les aspects d'une figure (taille, position,...) peuvent être contrôlés
  d'un point de vue /programmatique/ \to *reproductibilité* des figures et des
  résultats scientifiques

** Importation de =matplotlib=

- Convention d'importation
  #+BEGIN_SRC python
    In [1]: import matplotlib as mpl
    In [2]: import matplotlib.pyplot as plt
  #+END_SRC

** Comment afficher vos figures : =show()= or not =show()=

#+BEAMER: \setbeamercovered{invisible}

- Affichage depuis un script python
  #+BEGIN_SRC python -n
    import matplotlib.pyplot as plt
    import numpy as np

    x = np.linspace(0, 3*np.pi, 100)

    plt.plot(x, np.sin(x))
    plt.plot(x, np.cos(x))

    plt.show()
  #+END_SRC

  #+BEAMER: \pause

  #+BEGIN_SRC latex
    \begin{tikzpicture}[remember picture,overlay]
      \tikzset{codeblock/.style={color=#1!50,rounded corners=0.5ex, opacity=0.2, fill}}
      \draw[codeblock=blue] (0ex,4.5ex) rectangle (9ex,7ex);
      \node[blue] (t) [xshift=40ex, yshift=+10ex] {\small Utilisation de \texttt{\bf plt.show()}};
      \draw[->, blue] (t.west) to [out=180, in=0] (10ex, 5.5ex);
    \end{tikzpicture}
  #+END_SRC

** Comment afficher vos figures : =show()= or not =show()=

#+BEAMER: \setbeamercovered{invisible}

- Affichage depuis la console =ipython=
  #+BEGIN_SRC python
    In [1]: %matplotlib
    Using matplotlib backend: TkAgg

    In [2]: import matplotlib.pyplot as plt
    In [3]: import numpy as np

    In [4]: x = np.linspace(0, 3*np.pi, 100)

    In [6]: plt.plot(x, np.sin(x))
    In [7]: plt.plot(x, np.cos(x))
  #+END_SRC

  #+BEAMER: \pause

  #+BEGIN_SRC latex
    \begin{tikzpicture}[remember picture,overlay]
      \tikzset{codeblock/.style={color=#1!50,rounded corners=0.5ex, opacity=0.2, fill}}
      \draw[codeblock=blue] (6.5ex,22.5ex) rectangle (17ex,25ex);
      \node[blue] (t) [xshift=50ex, yshift=+21ex] {\small Utilisation de \texttt{\bf \%matplotlib}};
      \draw[->, blue] (t.west) to [out=180, in=0] (18ex, 23.5ex);
    \end{tikzpicture}
  #+END_SRC

- Possibilité également de lancer la commande =ipython= avec l'option =--matplotlib=

** Première figure sous =matplotlib=
*** Python code
:PROPERTIES:
:BEAMER_COL: 0.52
:END:

#+BEGIN_SRC python
  In [1]: %matplotlib
  In [2]: import matplotlib.pyplot as plt
  In [3]: import numpy as np

  In [4]: x = np.linspace(0, 3*np.pi, 100)

  In [5]: plt.plot(x, np.sin(x))
  In [6]: plt.plot(x, np.cos(x))
#+END_SRC

#+BEAMER: \pause
- Sauvegarder la figure (=svg=, =pdf=, =png=)
#+BEGIN_SRC python
  In [7]: plt.savefig("/tmp/mpl1.pdf")
#+END_SRC

*** Figure
:PROPERTIES:
:BEAMER_COL: 0.5
:END:

#+ATTR_LATEX: :width 1.1\linewidth
[[file:figures/mpl.pdf]]

** /Kozmetix/ sous =matplotlib=
#+BEAMER: \framesubtitle{Lignes, marqueurs : styles \& couleurs}
*** Python code
:PROPERTIES:
:BEAMER_COL: 0.52
:END:

#+BEAMER: \small

#+ATTR_LATEX: :options fontsize=\scriptsize
#+BEGIN_SRC python
  In [8]: plt.plot(x, x + 0, linestyle="solid")

  In [9]: plt.plot(x, x + 1, linestyle="dashed")

  In[10]: plt.plot(x, x + 2, linestyle="dashdot")

  In[11]: plt.plot(x, x + 3, linestyle="dotted")
#+END_SRC

#+BEAMER: \pause
- Il est également possible d'utiliser les notations raccourcies

  | =-=  | \equiv | =solid=   |
  | =--= | \equiv | =dashed=  |
  | =-.= | \equiv | =dashdot= |
  | =:=  | \equiv | =dotted=  |

*** Figure
:PROPERTIES:
:BEAMER_COL: 0.5
:END:

#+ATTR_LATEX: :width 1.1\linewidth
[[file:figures/mpl_line3.pdf]]

** /Kozmetix/ sous =matplotlib=
#+BEAMER: \framesubtitle{Lignes, marqueurs : styles \& couleurs}
*** Python code
:PROPERTIES:
:BEAMER_COL: 0.52
:END:

#+BEAMER: \small

#+ATTR_BEAMER: :overlay +-
- En spécifiant le nom de la couleur
  #+ATTR_LATEX: :options fontsize=\scriptsize
  #+BEGIN_SRC python
    In [8]: plt.plot(x, np.sin(x - 0), color="blue")
  #+END_SRC

- Nom raccourci (=rgbcmyk=)
  #+ATTR_LATEX: :options fontsize=\scriptsize
  #+BEGIN_SRC python
    In [9]: plt.plot(x, np.sin(x - 1), color="g")
  #+END_SRC

- Code héxadécimal (=RRGGBB=)
  #+ATTR_LATEX: :options fontsize=\scriptsize
  #+BEGIN_SRC python
    In[10]: plt.plot(x, np.sin(x - 3), color="#FFDD44")
  #+END_SRC

- Couleur du cycle =C0-9=
  #+ATTR_LATEX: :options fontsize=\scriptsize
  #+BEGIN_SRC python
    In[11]: plt.plot(x, np.sin(x - 5), color="C4")
  #+END_SRC

*** Figure
:PROPERTIES:
:BEAMER_COL: 0.5
:END:

#+BEGIN_SRC latex
  \begin{center}
    \includegraphics<1>[width=1.1\linewidth]{figures/mpl_color0.pdf}
    \includegraphics<2>[width=1.1\linewidth]{figures/mpl_color1.pdf}
    \includegraphics<3>[width=1.1\linewidth]{figures/mpl_color2.pdf}
    \includegraphics<4>[width=1.1\linewidth]{figures/mpl_color3.pdf}
  \end{center}
#+END_SRC

** COMMENT /Kozmetix/ sous =matplotlib=
#+BEAMER: \framesubtitle{Lignes, marqueurs : styles \& couleurs}
*** Python code
:PROPERTIES:
:BEAMER_COL: 0.52
:END:

#+BEAMER: \small\vskip+17pt
#+BEGIN_SRC python
  In [4]: x = np.linspace(0, 3*np.pi, 30)
  In [5]: plt.plot(x, np.sin(x), "o")
#+END_SRC

#+BEAMER: \pause\vskip-1pt
#+BEGIN_SRC python
  In [6]: plt.plot(x, np.sin(x), "p",
     ...:          markersize=15,
     ...:          markerfacecolor='pink',
     ...:          markeredgecolor='gray',
     ...:          markeredgewidth=2)
#+END_SRC

*** Figure
:PROPERTIES:
:BEAMER_COL: 0.5
:END:

#+BEGIN_SRC latex
  \begin{center}
    \includegraphics<1>[width=1.1\linewidth]{figures/mpl_marker0.pdf}
    \includegraphics<2>[width=1.1\linewidth]{figures/mpl_marker1.pdf}
  \end{center}
#+END_SRC
** /Kozmetix/ sous =matplotlib=
#+BEAMER: \framesubtitle{Lignes, marqueurs : styles \& couleurs}

#+BEGIN_SRC latex
  \begin{center}
    \includegraphics<1>[width=0.6\linewidth]{figures/mpl_marker0.pdf}
    \includegraphics<2>[width=0.6\linewidth]{figures/mpl_marker2.pdf}
  \end{center}
#+END_SRC

#+BEGIN_SRC python
 In [6]: plt.plot(x, np.sin(x), "o")
#+END_SRC

#+BEAMER: \pause\vskip-17pt
#+BEGIN_SRC python
 In [7]: for marker in ["o", ".", ",", "x", "+", "v", "^", "<", ">", "s", "d"]:
    ...:     plt.plot(np.random.rand(10), np.random.rand(10), marker)
#+END_SRC

** /Kozmetix/ sous =matplotlib=
#+BEAMER: \framesubtitle{Lignes, marqueurs : styles \& couleurs}
*** Python code
:PROPERTIES:
:BEAMER_COL: 0.52
:END:

#+BEAMER: \small
- Il est finalement possible de combiner style & couleur au sein d'une syntaxe
  minimaliste

  #+BEGIN_SRC python
    In [8]: plt.plot(x, x + 0, "-og")

    In [9]: plt.plot(x, x + 1, "--xc")

    In[10]: plt.plot(x, x + 2, "-..k")

    In[11]: plt.plot(x, x + 3, ":sr")
  #+END_SRC

- Pour découvrir l'ensemble des options d'affichage *=plt.plot?=* ou
  *=help(plt.plot)=*

*** Figure
:PROPERTIES:
:BEAMER_COL: 0.5
:END:

#+ATTR_LATEX: :width 1.1\linewidth
[[file:figures/mpl_colorline3.pdf]]

** /Kozmetix/ sous =matplotlib=
#+BEAMER: \framesubtitle{Définition des limites \& \emph{ticks}}

*** Figure
:PROPERTIES:
:BEAMER_COL: 0.5
:END:

#+BEGIN_SRC latex
  \begin{center}
    \includegraphics<1>[width=1.1\linewidth]{figures/mpl_limit0.pdf}
    \includegraphics<2>[width=1.1\linewidth]{figures/mpl_limit1.pdf}
    \includegraphics<3>[width=1.1\linewidth]{figures/mpl_limit2.pdf}
    \includegraphics<4-5>[width=1.1\linewidth]{figures/mpl_limit3.pdf}
  \end{center}
#+END_SRC

*** Python code
:PROPERTIES:
:BEAMER_COL: 0.52
:END:

#+BEAMER: \small\vskip+17pt
#+BEGIN_SRC python
  In [4]: x = np.linspace(0, 3*np.pi, 100)
  In [5]: plt.plot(x, np.sin(x))

  In [6]: plt.xlim(-1, 11)
  In [7]: plt.ylim(-1.5, 1.5)
#+END_SRC

#+BEAMER: \pause\vskip-17pt
#+BEGIN_SRC python
  In [8]: plt.axis([11, -1, 1.5, -1.5])
#+END_SRC

#+BEAMER: \pause\vskip-17pt
#+BEGIN_SRC python
  In [9]: plt.axis("tight")
#+END_SRC

#+BEAMER: \pause\vskip-17pt
#+BEGIN_SRC python
  In[10]: plt.axis("equal")
#+END_SRC

#+BEAMER: \pause
- Pour découvrir l'ensemble des options d'affichage *=plt.axis?=* ou
  *=help(plt.axis)=*

** /Kozmetix/ sous =matplotlib=
#+BEAMER: \framesubtitle{Définition des limites \& \emph{ticks}}

#+BEGIN_SRC latex
  \begin{center}
    \includegraphics<1>[width=0.6\linewidth]{figures/mpl_ticks0.pdf}
    \includegraphics<2>[width=0.6\linewidth]{figures/mpl_ticks1.pdf}
  \end{center}
#+END_SRC

#+ATTR_LATEX: :options fontsize=\scriptsize
#+BEGIN_SRC python
  In[11]: plt.xticks([0, np.pi/2, np.pi, 3*np.pi/2, 2*np.pi, 5*np.pi/2, 3*np.pi])
  In[12]: plt.yticks([-1, 0, +1])
#+END_SRC

#+BEAMER: \pause\vskip-17pt
#+ATTR_LATEX: :options fontsize=\scriptsize
#+BEGIN_SRC python
  In[13]: plt.xticks([0, np.pi/2, np.pi, 3*np.pi/2, 2*np.pi, 5*np.pi/2, 3*np.pi],
                     [r"$0$", r"$\pi/2$", r"$\pi$", r"$3\pi/2$", r"$2\pi", r"$5\pi/2$", r"$3\pi$"])
#+END_SRC

** /Kozmetix/ sous =matplotlib=
#+BEAMER: \framesubtitle{Définition des limites \& \emph{ticks}}

#+BEGIN_SRC latex
  \begin{center}
    \includegraphics<1>[width=0.6\linewidth]{figures/mpl_ticks1.pdf}
  \end{center}
#+END_SRC

#+ATTR_LATEX: :options fontsize=\scriptsize
#+BEGIN_SRC python
  In[11]: plt.xticks([0, np.pi/2, np.pi, 3*np.pi/2, 2*np.pi, 5*np.pi/2, 3*np.pi])
  In[12]: plt.yticks([-1, 0, +1])
#+END_SRC

#+BEAMER: \vskip-17pt
#+ATTR_LATEX: :options fontsize=\scriptsize
#+BEGIN_SRC python
  In[13]: plt.xticks([0, np.pi/2, np.pi, 3*np.pi/2, 2*np.pi, 5*np.pi/2, 3*np.pi],
                     [r"$0$", r"$\pi/2$", r"$\pi$", r"$3\pi/2$", r"$2\pi", r"$5\pi/2$", r"$3\pi$"])
#+END_SRC

#+ATTR_LATEX: :options [5][lbtuc][\centering][10][8]
#+BEGIN_CBOX
#+BEGIN_REMARK
Le prefixe =r= pour /raw-text/ indique que la chaîne de caractères doit être traiter
sans échapper les caractères précédés de =\=
#+END_REMARK
#+END_CBOX

** COMMENT /Kozmetix/ sous =matplotlib=
#+BEAMER: \framesubtitle{Définition des limites \& \emph{ticks}}

*** Figure
:PROPERTIES:
:BEAMER_COL: 0.5
:END:

#+BEGIN_SRC latex
  \begin{center}
    \includegraphics<1>[width=1.1\linewidth]{figures/mpl_axis0.pdf}
    \includegraphics<2>[width=1.1\linewidth]{figures/mpl_axis1.pdf}
    \includegraphics<3>[width=1.1\linewidth]{figures/mpl_axis2.pdf}
    \includegraphics<4>[width=1.1\linewidth]{figures/mpl_axis3.pdf}
  \end{center}
#+END_SRC

*** Python code
:PROPERTIES:
:BEAMER_COL: 0.52
:END:

#+BEAMER: \small\vskip+17pt
- Accéder aux axes de la figure (=gca= \equiv =get current axis=)

#+ATTR_LATEX: :options fontsize=\scriptsize
#+BEGIN_SRC python
  In [4]: ax = plt.gca()
  In [5]: ax.grid()
#+END_SRC

#+BEAMER: \pause\vskip-1pt
#+ATTR_LATEX: :options fontsize=\scriptsize
#+BEGIN_SRC python
  In [6]: ax.spines["right"].set_color("none")
#+END_SRC

#+BEAMER: \pause\vskip-1pt
#+ATTR_LATEX: :options fontsize=\scriptsize
#+BEGIN_SRC python
  In [7]: ax.spines["top"].set_color("none")
#+END_SRC

#+BEAMER: \pause\vskip-1pt
#+ATTR_LATEX: :options fontsize=\scriptsize
#+BEGIN_SRC python
  In [8]: ax.spines["bottom"].set_position(("data",0))
#+END_SRC

** /Kozmetix/ sous =matplotlib=
#+BEAMER: \framesubtitle{\emph{Labelling} : titre, axes, légendes et autres annotations}

*** Figure
:PROPERTIES:
:BEAMER_COL: 0.5
:END:

#+BEGIN_SRC latex
  \begin{center}
    \includegraphics<1->[width=1.1\linewidth]{figures/mpl_title.pdf}
  \end{center}
#+END_SRC

*** Python code
:PROPERTIES:
:BEAMER_COL: 0.52
:END:

#+BEAMER: \small\vskip+17pt
#+ATTR_LATEX: :options fontsize=\scriptsize
#+BEGIN_SRC python
  In [4]: x = np.linspace(0, 3*np.pi, 100)
  In [5]: plt.plot(x, np.sin(x))

  In [6]: plt.title("Variation de la fonction sinus")
  In [7]: plt.xlabel(r"$\theta$")
  In [8]: plt.ylabel(r"$\cos\theta$")
#+END_SRC

** /Kozmetix/ sous =matplotlib=
#+BEAMER: \framesubtitle{\emph{Labelling} : titre, axes, légendes et autres annotations}
*** Figure
:PROPERTIES:
:BEAMER_COL: 0.5
:END:

#+BEGIN_SRC latex
  \begin{center}
    \includegraphics<1>[width=1.1\linewidth]{figures/mpl_legend0.pdf}
    \includegraphics<2->[width=1.1\linewidth]{figures/mpl_legend2.pdf}
  \end{center}
#+END_SRC

*** Python code
:PROPERTIES:
:BEAMER_COL: 0.52
:END:

#+BEAMER: \small\vskip+17pt
#+ATTR_LATEX: :options fontsize=\scriptsize
#+BEGIN_SRC python
  In [4]: x = np.linspace(0, 3*np.pi, 100)
  In [5]: plt.plot(x, np.sin(x), label=r"$\sin\theta$")
  In [6]: plt.plot(x, np.cos(x), label=r"$\cos\theta$")
  In [7]: plt.axis("equal")

  In [8]: plt.legend()
#+END_SRC

#+BEAMER: \pause\vskip-17pt
#+ATTR_LATEX: :options fontsize=\scriptsize
#+BEGIN_SRC python
  In[10]: plt.legend(loc="lower center", frameon=False, ncol=2)
#+END_SRC

- Pour découvrir l'ensemble des options d'affichage *=plt.legend?=* ou
  *=help(plt.legend)=*

** /Kozmetix/ sous =matplotlib=
#+BEAMER: \framesubtitle{\emph{Labelling} : titre, axes, légendes et autres annotations}

#+BEGIN_SRC latex
  \begin{center}
    \includegraphics<1>[width=0.6\linewidth]{figures/mpl_text0.pdf}
    \includegraphics<2>[width=0.6\linewidth]{figures/mpl_text1.pdf}
  \end{center}
#+END_SRC

#+ATTR_LATEX: :options fontsize=\scriptsize
#+BEGIN_SRC python
  In[11]: plt.text(0, 3, "Matplotlib rocks !")
#+END_SRC

#+BEAMER: \pause\vskip-17pt
#+ATTR_LATEX: :options fontsize=\scriptsize
#+BEGIN_SRC python
  In[12]: plt.annotate(r"$\cos\left(\frac{\pi}{2}\right)=0$",
                       xy=(np.pi/2, np.cos(np.pi/2)), xytext=(3, 2),
                       arrowprops=dict(arrowstyle="->", connectionstyle="arc3,rad=.2"))
#+END_SRC

** /Scatter plot/

*** Figure
:PROPERTIES:
:BEAMER_COL: 0.5
:END:

#+BEGIN_SRC latex
  \begin{center}
    \includegraphics<1>[width=1.1\linewidth]{figures/mpl_scatter0.pdf}
    \includegraphics<2>[width=1.1\linewidth]{figures/mpl_scatter1.pdf}
  \end{center}
#+END_SRC

*** Python code
:PROPERTIES:
:BEAMER_COL: 0.52
:END:

#+BEAMER: \vskip+17pt
#+ATTR_LATEX: :options fontsize=\scriptsize
#+BEGIN_SRC python
  In [1]: x = np.linspace(0, 3*np.pi, 30)
  In [2]: plt.scatter(x, np.sin(x), marker="o")
#+END_SRC

#+BEAMER: \pause\vskip-17pt
#+ATTR_LATEX: :options fontsize=\scriptsize
#+BEGIN_SRC python
  In [3]: plt.plot(x, np.cos(x), "o", color="orange")
#+END_SRC

** /Scatter plot/

- Le mode /scatter/ permet de contrôler (taille, couleur) chaque point/marqueur
  individuellement

*** Figure
:PROPERTIES:
:BEAMER_COL: 0.5
:END:

#+BEGIN_SRC latex
  \begin{center}
    \includegraphics<1>[width=1.1\linewidth]{figures/mpl_scatter2.pdf}
  \end{center}
#+END_SRC

*** Python code
:PROPERTIES:
:BEAMER_COL: 0.52
:END:

#+BEAMER: \vskip+17pt
#+ATTR_LATEX: :options fontsize=\scriptsize
#+BEGIN_SRC python
  In [1]: rng = np.random
  In [2]: x = rng.randn(100)
  In [3]: y = rng.randn(100)
  In [4]: colors = rng.rand(100)
  In [5]: sizes = 1000 * rng.rand(100)

  In [6]: plt.grid()
  In [7]: plt.scatter(x, y, c=colors, s=sizes, alpha=0.3,
                      cmap="viridis")
  In [8]: plt.colorbar()
#+END_SRC
** Barres d'erreur
*** Python code
:PROPERTIES:
:BEAMER_COL: 0.52
:END:

#+BEAMER: \vskip+17pt
#+ATTR_LATEX: :options fontsize=\scriptsize
#+BEGIN_SRC python
  In [1]: x = np.linspace(0, 10, 50)
  In [2]: dy = 0.8
  In [3]: y = np.sin(x) + dy * np.random.randn(50)

  In [4]: plt.errorbar(x, y, yerr=dy, fmt="o")
  In [5]: plt.plot(x, np.sin(x))
#+END_SRC

#+BEAMER: \pause\vskip-17pt
#+ATTR_LATEX: :options fontsize=\scriptsize
#+BEGIN_SRC python
  In [6]: plt.errorbar(x, y, yerr=dy,
                       fmt="o", color="black",
                       ecolor="lightgray",
                       elinewidth=3,
                       capsize=0)
#+END_SRC

#+BEAMER: \pause\vskip-17pt
#+ATTR_LATEX: :options fontsize=\scriptsize
#+BEGIN_SRC python
  In [7]: plt.fill_between(x, np.sin(x)-dy, np.sin(x)+dy,
                           alpha=0.2, color="gray")
#+END_SRC

*** Figure
:PROPERTIES:
:BEAMER_COL: 0.5
:END:

#+BEGIN_SRC latex
  \begin{center}
    \includegraphics<1>[width=1.1\linewidth]{figures/mpl_errorbar0.pdf}
    \includegraphics<2>[width=1.1\linewidth]{figures/mpl_errorbar1.pdf}
    \includegraphics<3>[width=1.1\linewidth]{figures/mpl_errorbar2.pdf}
  \end{center}
#+END_SRC

** Histogramme 1D
*** Python code
:PROPERTIES:
:BEAMER_COL: 0.52
:END:

#+BEAMER: \vskip+17pt
#+ATTR_LATEX: :options fontsize=\scriptsize
#+BEGIN_SRC python
  In [1]: data = np.random.randn(1000)
  In [2]: plt.hist(data)
#+END_SRC

#+BEAMER: \pause\vskip-17pt
#+ATTR_LATEX: :options fontsize=\scriptsize
#+BEGIN_SRC python
  In [3]: plt.hist(data, bins=30, normed=True)
#+END_SRC

- Pour découvrir l'ensemble des options d'affichage *=plt.hist?=* ou
  *=help(plt.hist)=*

*** Figure
:PROPERTIES:
:BEAMER_COL: 0.5
:END:

#+BEGIN_SRC latex
  \begin{center}
    \includegraphics<1>[width=1.1\linewidth]{figures/mpl_histogram0.pdf}
    \includegraphics<2>[width=1.1\linewidth]{figures/mpl_histogram1.pdf}
  \end{center}
#+END_SRC

** Histogramme 1D
*** Python code
:PROPERTIES:
:BEAMER_COL: 0.52
:END:

#+BEAMER: \vskip+17pt
#+ATTR_LATEX: :options fontsize=\scriptsize
#+BEGIN_SRC python
  In [0]: x1 = np.random.normal(0, 0.8, 1000)
  In [1]: x2 = np.random.normal(-2, 1, 1000)
  In [2]: x3 = np.random.normal(3, 2, 1000)

  In [3]: kwargs = dict(histtype="stepfilled", alpha=0.5,
                        normed=True, bins=40)

  In [4]: plt.hist(x1, **kwargs)
  In [5]: plt.hist(x2, **kwargs)
  In [6]: plt.hist(x3, **kwargs);
#+END_SRC

*** Figure
:PROPERTIES:
:BEAMER_COL: 0.5
:END:

#+BEGIN_SRC latex
  \begin{center}
    \includegraphics<1>[width=1.1\linewidth]{figures/mpl_histogram2.pdf}
  \end{center}
#+END_SRC
** Histogramme 2D
*** Python code
:PROPERTIES:
:BEAMER_COL: 0.52
:END:

#+BEAMER: \vskip+17pt
#+ATTR_LATEX: :options fontsize=\scriptsize
#+BEGIN_SRC python
  In [1]: mean = [0, 0]
  In [2]: cov = [[1, 1], [1, 2]]
  In [3]: x, y = np.random.multivariate_normal(mean, cov, 10000).T

  In [4]: plt.hist2d(x, y, bins=30, cmap="Blues")
  In [5]: plt.colorbar()
#+END_SRC

*** Figure
:PROPERTIES:
:BEAMER_COL: 0.5
:END:

#+BEGIN_SRC latex
  \begin{center}
    \includegraphics<1>[width=1.1\linewidth]{figures/mpl_histogram3.pdf}
  \end{center}
#+END_SRC
** Contours & densités

#+BEGIN_SRC latex
  \begin{align*}
    z = f(x,y) =& \sin^{10} x + \cos(x\cdot y)\cdot\cos x\\
    =&\sin^{10}\begin{bmatrix}
    x_0&\cdots
    \end{bmatrix}+\cos\left(\begin{bmatrix}
        x_0&\cdots
      \end{bmatrix}\cdot\begin{bmatrix}
    y_0\\\vdots\end{bmatrix}\right)\cdot\cos\begin{bmatrix}
        x_0&\cdots
      \end{bmatrix}
  \end{align*}
#+END_SRC

#+BEAMER: \vskip-20pt
*** Python code
:PROPERTIES:
:BEAMER_COL: 0.55
:END:

#+ATTR_LATEX: :options fontsize=\scriptsize
#+BEGIN_SRC python
  In [1]: def f(x, y):
     ...:     return np.sin(x)**10 + np.cos(x*y) * np.cos(x)

  In [2]: x = np.linspace(0, 5, 500)
  In [3]: y = np.linspace(0, 5, 500)

  In [4]: X, Y = np.meshgrid(x, y)
  In [5]: Z = f(X, Y)

  In [6]: contours = plt.contour(X, Y, Z, 3, colors='black')
  In [7]: plt.clabel(contours, inline=True, fontsize=8)

  In [8]: plt.imshow(Z, extent=[0, 5, 0, 5], origin='lower',
                     cmap='RdGy', alpha=0.5)
  In [9]: plt.colorbar();
#+END_SRC

*** Color map
:PROPERTIES:
:BEAMER_COL: 0.55
:END:

#+BEAMER: \visible<2>{
#+ATTR_LATEX: :width 1.1\linewidth
[[file:figures/mpl_contour.pdf]]
#+BEAMER: }
** Figure 3D
*** Python code
:PROPERTIES:
:BEAMER_COL: 0.52
:END:

#+ATTR_BEAMER: :overlay +-
- La représentation 3D suppose le chargement de l'outil *=mplot3d=* inclus par
  défaut dans =matplotlib=

  #+BEGIN_SRC python
    In [1]: from mpl_toolkits import mplot3d
  #+END_SRC

- Une vue 3D est initialisée en spécifiant le type de projection

  #+BEGIN_SRC python
    In [2]: ax = plt.axes(projection="3d")
  #+END_SRC

*** Figure
:PROPERTIES:
:BEAMER_COL: 0.5
:END:

#+BEGIN_SRC latex
  \begin{center}
    \includegraphics<2>[width=1.1\linewidth]{figures/mpl_3d0.pdf}
  \end{center}
#+END_SRC


#+BEGIN_COMMENT
http://nbviewer.jupyter.org/github/jakevdp/PythonDataScienceHandbook/blob/master/notebooks/04.12-Three-Dimensional-Plotting.ipynb

http://nbviewer.jupyter.org/github/jrjohansson/scientific-python-lectures/blob/master/Lecture-4-Matplotlib.ipynb#Coutour-plots-with-projections
#+END_COMMENT
** Figure 3D
#+BEAMER: \framesubtitle{\texttt{plot3D} \& \texttt{scatter3D}}

*** Python code
:PROPERTIES:
:BEAMER_COL: 0.52
:END:

#+BEAMER: \vskip+17pt
#+ATTR_LATEX: :options fontsize=\scriptsize
#+BEGIN_SRC python
  In [2]: ax = plt.axes(projection="3d")

  In [3]: # Data for a three-dimensional line
  In [4]: zline = np.linspace(0, 15, 1000)
  In [5]: xline = np.sin(zline)
  In [6]: yline = np.cos(zline)
  In [7]: ax.plot3D(xline, yline, zline, "gray")
#+END_SRC

#+BEAMER: \pause\vskip-17pt
#+ATTR_LATEX: :options fontsize=\scriptsize
#+BEGIN_SRC python
  In [8]: # Data for three-dimensional scattered points
  In [9]: zdata = 15 * np.random.random(100)
  In[10]: xdata = np.sin(zdata) + 0.1*np.random.randn(100)
  In[11]: ydata = np.cos(zdata) + 0.1*np.random.randn(100)
  In[12]: ax.scatter3D(xdata, ydata, zdata, c=zdata)
#+END_SRC

*** Figure
:PROPERTIES:
:BEAMER_COL: 0.5
:END:

#+BEGIN_SRC latex
  \begin{center}
    \includegraphics<1>[width=1.1\linewidth]{figures/mpl_3d1.pdf}
    \includegraphics<2>[width=1.1\linewidth]{figures/mpl_3d2.pdf}
  \end{center}
#+END_SRC


#+BEGIN_COMMENT
http://nbviewer.jupyter.org/github/jakevdp/PythonDataScienceHandbook/blob/master/notebooks/04.12-Three-Dimensional-Plotting.ipynb

http://nbviewer.jupyter.org/github/jrjohansson/scientific-python-lectures/blob/master/Lecture-4-Matplotlib.ipynb#Coutour-plots-with-projections
#+END_COMMENT
** Figure 3D
#+BEAMER: \framesubtitle{\texttt{plot\_wireframe} \& \texttt{plot\_surface}}

*** Python code
:PROPERTIES:
:BEAMER_COL: 0.52
:END:

- $f(x,y) = \sin(\sqrt{x^2+y^2})$

  #+ATTR_LATEX: :options fontsize=\scriptsize
  #+BEGIN_SRC python
    In [2]: ax = plt.axes(projection="3d")
    In [3]: def f(x, y):
       ...:     return np.sin(np.sqrt(x**2 + y**2))

    In [4]: x = np.linspace(-6, 6, 30)
    In [5]: y = np.linspace(-6, 6, 30)

    In [6]: X, Y = np.meshgrid(x, y)
    In [7]: Z = f(X, Y)
  #+END_SRC

  #+BEAMER: \pause\vskip-17pt
  #+ATTR_LATEX: :options fontsize=\scriptsize
  #+BEGIN_SRC python
    In [8]: ax.plot_wireframe(X, Y, Z, linewidth=0.5
                              color="gray")
  #+END_SRC

  #+BEAMER: \pause\vskip-17pt
  #+ATTR_LATEX: :options fontsize=\scriptsize
  #+BEGIN_SRC python
    In [9]: ax.plot_surface(X, Y, Z, cmap="viridis")
  #+END_SRC

*** Figure
:PROPERTIES:
:BEAMER_COL: 0.5
:END:

#+BEGIN_SRC latex
  \begin{center}
    \includegraphics<2>[width=1.1\linewidth]{figures/mpl_3dwireframe.pdf}
    \includegraphics<3>[width=1.1\linewidth]{figures/mpl_3dsurface.pdf}
  \end{center}
#+END_SRC
** COMMENT Figure 3D
#+BEAMER: \framesubtitle{\texttt{plot\_wireframe} \& \texttt{plot\_surface}}

*** Python code
:PROPERTIES:
:BEAMER_COL: 0.52
:END:

- $f(x,y) = \sin(\sqrt{x^2+y^2})$

  #+ATTR_LATEX: :options fontsize=\scriptsize
  #+BEGIN_SRC python
    In [2]: ax = plt.axes(projection="3d")
    In [3]: def f(x, y):
       ...:     return np.sin(np.sqrt(x**2 + y**2))

    In [4]: x = np.linspace(-6, 6, 30)
    In [5]: y = np.linspace(-6, 6, 30)

    In [6]: X, Y = np.meshgrid(x, y)
    In [7]: Z = f(X, Y)
    In [9]: ax.plot_surface(X, Y, Z, alpha=0.25,
                            edgecolor="k", linewidth=0.1)

  #+END_SRC
  #+BEAMER: \pause\vskip-1pt
  #+ATTR_LATEX: :options fontsize=\scriptsize
  #+BEGIN_SRC python
    In[10]: ax.contour(X, Y, Z, zdir='z', offset=+1)
    In[11]: ax.contour(X, Y, Z, zdir='y', offset=-7)
    In[12]: ax.contour(X, Y, Z, zdir='x', offset=+7)
    In[13]: ax.set_zlim3d(-1, 1)
    In[14]: ax.set_ylim3d(-7, 7)
    In[15]: ax.set_xlim3d(-7, 7)
  #+END_SRC

*** Figure
:PROPERTIES:
:BEAMER_COL: 0.5
:END:

#+BEGIN_SRC latex
  \begin{center}
    \includegraphics<1>[width=1.1\linewidth]{figures/mpl_3dcontour0.pdf}
    \includegraphics<2>[width=1.1\linewidth]{figures/mpl_3dcontour1.pdf}
  \end{center}
#+END_SRC
** /Subplot/

- =matplotlib= permet une gestion relativement aisée du placement des figures et
  de leurs sous-figures

*** Python code
:PROPERTIES:
:BEAMER_COL: 0.52
:END:

#+BEAMER: \small\vskip5pt
#+ATTR_LATEX: :options fontsize=\scriptsize
#+BEGIN_SRC python
  In [2]: ax1 = plt.axes()
#+END_SRC
#+BEAMER: \pause\vskip-25pt
#+ATTR_LATEX: :options fontsize=\scriptsize
#+BEGIN_SRC python
  In [3]: ax2 = plt.axes([0.65, 0.65, 0.2, 0.2])
#+END_SRC

#+BEAMER: \small\vskip+5pt
où =axes([x, y, w, h])= et *=x,y,w,h= exprimés en fraction du canevas initial*

*** Figure
:PROPERTIES:
:BEAMER_COL: 0.5
:END:

#+BEGIN_SRC latex
  \begin{center}
    \includegraphics<1>[width=1.1\linewidth]{figures/mpl_subplot0.pdf}
    \includegraphics<2>[width=1.1\linewidth]{figures/mpl_subplot1.pdf}
  \end{center}
#+END_SRC
** /Subplot/

- =matplotlib= permet une gestion relativement aisée du placement des figures et
  de leurs sous-figures

*** Python code
:PROPERTIES:
:BEAMER_COL: 0.52
:END:

#+BEAMER: \vskip+17pt
#+ATTR_LATEX: :options fontsize=\scriptsize
#+BEGIN_SRC python
  In [2]: x = np.linspace(-1, 1, 1000)
  In [3]: plt.plot(x, x**2, x, x**3)

  In [4]: inset = plt.axes([0.6, 0.2, 0.25, 0.25])

  In [5]: inset.plot(x, x**2, x, x**3)
  In [6]: inset.set_title("zoom x = 0")
  In [7]: inset.set_xlim(-0.2, +0.2)
  In [8]: inset.set_ylim(-0.005, +0.01)
#+END_SRC

*** Figure
:PROPERTIES:
:BEAMER_COL: 0.5
:END:

#+BEGIN_SRC latex
  \begin{center}
    \includegraphics<1>[width=1.1\linewidth]{figures/mpl_subplot2.pdf}
  \end{center}
#+END_SRC
** /Subplot/

- La commande *=subplot=* permet la génération *sous-figure par sous-figure* selon
  une représentation matricielle

*** Python code
:PROPERTIES:
:BEAMER_COL: 0.52
:END:

#+ATTR_LATEX: :options fontsize=\scriptsize
#+BEGIN_SRC python
  In [2]: plt.subplot(2, 3, 1)
#+END_SRC
#+BEAMER: \pause\vskip-28pt
#+ATTR_LATEX: :options fontsize=\scriptsize
#+BEGIN_SRC python
  In [3]: plt.subplot(2, 3, 3)
#+END_SRC
#+BEAMER: \pause\vskip-28pt
#+ATTR_LATEX: :options fontsize=\scriptsize
#+BEGIN_SRC python
  In [4]: plt.subplot(2, 3, 5)
#+END_SRC

*** Figure
:PROPERTIES:
:BEAMER_COL: 0.5
:END:

#+BEGIN_SRC latex
  \begin{center}
    \includegraphics<1>[width=1.1\linewidth]{figures/mpl_subplot3.pdf}
    \includegraphics<2>[width=1.1\linewidth]{figures/mpl_subplot4.pdf}
    \includegraphics<3>[width=1.1\linewidth]{figures/mpl_subplot5.pdf}
  \end{center}
#+END_SRC
** /Subplot/

- La commande *=subplots=* permet la génération de *l'ensemble des sous-figures*
  selon une représentation matricielle

*** Python code
:PROPERTIES:
:BEAMER_COL: 0.52
:END:

#+ATTR_LATEX: :options fontsize=\scriptsize
#+BEGIN_SRC python
  In [2]: plt.subplots(2, 3)
#+END_SRC
#+BEAMER: \pause\vskip-28pt
#+ATTR_LATEX: :options fontsize=\scriptsize
#+BEGIN_SRC python
  In [3]: plt.subplots_adjust(hspace=0.4, wspace=0.4)
#+END_SRC
#+BEAMER: \pause\vskip-28pt
#+ATTR_LATEX: :options fontsize=\scriptsize
#+BEGIN_SRC python
  In [4]: plt.subplots(2, 3, sharex="col", sharey="row")
#+END_SRC
#+BEAMER: \pause\vskip-28pt
#+ATTR_LATEX: :options fontsize=\scriptsize
#+BEGIN_SRC python
  In [5]: fig, ax = plt.subplots(2, 3, sharex="col", sharey="row")
  In [6]: for i in range(2):
     ...:     for j in range(3):
     ...:         ax[i, j].text(0.5, 0.5, str((i, j)),
     ...:                       fontsize=18, ha="center")
#+END_SRC

*** Figure
:PROPERTIES:
:BEAMER_COL: 0.5
:END:

#+BEGIN_SRC latex
  \begin{center}
    \includegraphics<1>[width=1.1\linewidth]{figures/mpl_subplot6.pdf}
    \includegraphics<2>[width=1.1\linewidth]{figures/mpl_subplot7.pdf}
    \includegraphics<3>[width=1.1\linewidth]{figures/mpl_subplot8.pdf}
    \includegraphics<4>[width=1.1\linewidth]{figures/mpl_subplot9.pdf}
  \end{center}
#+END_SRC

** COMMENT /Subplot/

- La commande *=GridSpec=* ne génère pas de figures ou sous figures mais facilite
  la gestion et notamment la fusion d'espaces réservés aux sous-figures

*** Python code
:PROPERTIES:
:BEAMER_COL: 0.52
:END:

#+ATTR_LATEX: :options fontsize=\scriptsize
#+BEGIN_SRC python
  In [2]: grid = plt.GridSpec(2, 3, hspace=0.4, wspace=0.4)
#+END_SRC
#+BEAMER: \pause\vskip-1pt
#+ATTR_LATEX: :options fontsize=\scriptsize
#+BEGIN_SRC python
  In [3]: plt.subplot(grid[0, 0])
#+END_SRC
#+BEAMER: \pause\vskip-1pt
#+ATTR_LATEX: :options fontsize=\scriptsize
#+BEGIN_SRC python
  In [4]: plt.subplot(grid[0, 1:])
#+END_SRC
#+BEAMER: \pause\vskip-1pt
#+ATTR_LATEX: :options fontsize=\scriptsize
#+BEGIN_SRC python
  In [5]: plt.subplot(grid[1, :2])
#+END_SRC
#+BEAMER: \pause\vskip-1pt
#+ATTR_LATEX: :options fontsize=\scriptsize
#+BEGIN_SRC python
  In [6]: plt.subplot(grid[1, 2])
#+END_SRC

*** Figure
:PROPERTIES:
:BEAMER_COL: 0.5
:END:

#+BEGIN_SRC latex
  \begin{center}
    \includegraphics<2>[width=1.1\linewidth]{figures/mpl_subplot10.pdf}
    \includegraphics<3>[width=1.1\linewidth]{figures/mpl_subplot11.pdf}
    \includegraphics<4>[width=1.1\linewidth]{figures/mpl_subplot12.pdf}
    \includegraphics<5>[width=1.1\linewidth]{figures/mpl_subplot13.pdf}
  \end{center}
#+END_SRC

** COMMENT /Subplot/
*** Python code
:PROPERTIES:
:BEAMER_COL: 0.52
:END:

#+ATTR_LATEX: :options fontsize=\scriptsize
#+BEGIN_SRC python -n
  import numpy as np
  import matplotlib.pyplot as plt

  # Create some normally distributed data
  mean = [0, 0]
  cov = [[1, 1], [1, 2]]
  x, y = np.random.multivariate_normal(mean, cov, 3000).T

  # Set up the axes with gridspec
  plt.figure(figsize=(6, 6))
  grid = plt.GridSpec(4, 4, hspace=0, wspace=0)
  main_ax = plt.subplot(grid[:-1, 1:])
  y_hist = plt.subplot(grid[:-1, 0],
                       xticklabels=[], sharey=main_ax)
  x_hist = plt.subplot(grid[-1, 1:],
                       yticklabels=[], sharex=main_ax)

  # scatter points on the main axes
  main_ax.plot(x, y, "ok", markersize=3, alpha=0.2)

  # histogram on the attached axes
  x_hist.hist(x, 40, histtype="stepfilled",
              orientation="vertical", color="gray")
  x_hist.invert_yaxis()

  y_hist.hist(y, 40, histtype="stepfilled",
              orientation="horizontal", color="gray")
  y_hist.invert_xaxis()

  plt.show()
#+END_SRC

*** Figure
:PROPERTIES:
:BEAMER_COL: 0.5
:END:

#+BEGIN_SRC latex
  \begin{center}
    \includegraphics<1>[width=1.1\linewidth]{figures/mpl_subplot14.pdf}
  \end{center}
#+END_SRC

* Interaction avec =matplotlib=
** Titre
:PROPERTIES:
:BEAMER_ENV: fullframe
:END:

#+BEGIN_EXPORT beamer
\title{Interaction avec \texttt{matplotlib}}
\titlepage
#+END_EXPORT

** Interface graphique sous =matplotlib=

#+ATTR_BEAMER: :overlay +-
- =matplotlib= propose une interface relativement rudimentaire pour interagir avec
  les objets graphiques

- Parmi les /widgets/ ou objets de contrôle
  - *=Cursor/MultiCursor=* permet l'affichage des valeurs dans la barre d'état
  - *=Slider=* permet la variation d'une quantité numérique
  - *=Button=* de générer une action définie par l'utilisateur lors du clic souris
  - *=CheckButtons/RadioButtons=* permet l'activation/désactivation de
    fonctionnalités graphiques
  - =Selector=, =Menu=,...

- Importation des /widgets/

  #+BEGIN_SRC python
    from matplotlib.widgets import Cursor, Slider, Button
  #+END_SRC

** Interface graphique sous =matplotlib=
#+BEAMER: \framesubtitle{Utilisation de curseurs}

*** Figure
:PROPERTIES:
:BEAMER_COL: 0.5
:END:

#+BEGIN_SRC latex
  \begin{center}
    \vspace{-1cm}
    \includegraphics<1>[width=1.1\linewidth]{figures/mpl_widget_cursor0.png}
    \includegraphics<2>[width=1.1\linewidth]{figures/mpl_widget_cursor1.png}
  \end{center}
#+END_SRC

*** Python code
:PROPERTIES:
:BEAMER_COL: 0.52
:END:

#+ATTR_LATEX: :options fontsize=\scriptsize
#+BEGIN_SRC python
  In [1]: import numpy as np
  In [2]: x, y = np.random.rand(2, 100)

  In [3]: import matplotlib.pyplot as plt
  In [4]: plt.figure(figsize=(6,6))
  In [5]: plt.scatter(x, y, c=x*y, alpha=0.5)
#+END_SRC

#+BEAMER: \pause\vskip-17pt
#+ATTR_LATEX: :options fontsize=\scriptsize
#+BEGIN_SRC python
  In [6]: from matplotlib.widgets import Cursor
  In [7]: cursor = Cursor(plt.gca(), color="red", lw=2)
#+END_SRC

** Interface graphique sous =matplotlib=
#+BEAMER: \framesubtitle{Utilisation de curseurs}

*** Figure
:PROPERTIES:
:BEAMER_COL: 0.5
:END:

#+BEGIN_SRC latex
  \begin{center}
    \vspace{-0.5cm}
    \includegraphics<1>[width=1.1\linewidth]{figures/mpl_widget_multicursor.png}
  \end{center}
#+END_SRC

*** Python code
:PROPERTIES:
:BEAMER_COL: 0.52
:END:

#+ATTR_LATEX: :options fontsize=\scriptsize
#+BEGIN_SRC python
  In [1]: import numpy as np
  In [2]: t = np.arange(0.0, np.pi, 0.01)

  In [3]: import matplotlib.pyplot as plt
  In [4]: fig, ax = plt.subplots(2, 1, sharex="col")
  In [5]: plt.subplots_adjust(hspace=0)
  In [6]: ax[0].plot(t, np.sin(2*np.pi*t))
  In [7]: ax[1].plot(t, np.sin(4*np.pi*t))

  In [8]: from matplotlib.widgets import MultiCursor
  In [9]: multi = MultiCursor(fig.canvas, (ax[0], ax[1]),
     ...:                     color="red", lw=2)
#+END_SRC
** Interface graphique sous =matplotlib=
#+BEAMER: \framesubtitle{Utilisation de \texttt{sliders}}

*** Figure
:PROPERTIES:
:BEAMER_COL: 0.5
:END:

#+BEGIN_SRC latex
  \begin{center}
    \vspace{-0.5cm}
    \includegraphics<1>[width=1.1\linewidth]{figures/mpl_widget_slider0.png}
    \includegraphics<2>[width=1.1\linewidth]{figures/mpl_widget_slider1.png}
    \includegraphics<3>[width=1.1\linewidth]{figures/mpl_widget_slider2.png}
    \includegraphics<4>[width=1.1\linewidth]{figures/mpl_widget_slider3.png}
  \end{center}
#+END_SRC

*** Python code
:PROPERTIES:
:BEAMER_COL: 0.52
:END:

#+ATTR_LATEX: :options fontsize=\scriptsize
#+BEGIN_SRC python
  In [1]: import numpy as np
  In [2]: t = np.arange(0.0, np.pi, 0.01)

  In [3]: a0, f0 = 5, 1
  In [4]: def signal(t, a=a0, f=f0):
     ...:     return a*np.sin(2*np.pi*f*t)

  In [5]: import matplotlib.pyplot as plt
  In [6]: fig, ax = plt.subplots()
  In [7]: l, = plt.plot(t, signal(t))
#+END_SRC

#+BEAMER: \pause\vskip-17pt
#+ATTR_LATEX: :options fontsize=\scriptsize
#+BEGIN_SRC python
  In [8]: axfreq = plt.axes([0.25, 0.10, 0.65, 0.03])
  In [9]: axamp  = plt.axes([0.25, 0.15, 0.65, 0.03])
#+END_SRC

#+BEAMER: \pause\vskip-17pt
#+ATTR_LATEX: :options fontsize=\scriptsize
#+BEGIN_SRC python
  In[10]: plt.subplots_adjust(bottom=0.25)
#+END_SRC

#+BEAMER: \pause\vskip-17pt
#+ATTR_LATEX: :options fontsize=\scriptsize
#+BEGIN_SRC python
  In[11]: from matplotlib.widgets import Slider
  In[12]: sfreq = Slider(axfreq, "Fréquence", 0.1, 30.0,
                         valinit=f0)
  In[13]: samp = Slider(axamp, "Amplitude", 0.1, 10.0,
                        valinit=a0)
#+END_SRC
** Interface graphique sous =matplotlib=
#+BEAMER: \framesubtitle{Utilisation de \texttt{sliders}}

*** Figure
:PROPERTIES:
:BEAMER_COL: 0.5
:END:

#+BEGIN_SRC latex
  \begin{center}
    \vspace{-0.5cm}
    \includegraphics<1-2>[width=1.1\linewidth]{figures/mpl_widget_slider3.png}
    \includegraphics<3>[width=1.1\linewidth]{figures/mpl_widget_slider4.png}
  \end{center}
#+END_SRC

*** Python code
:PROPERTIES:
:BEAMER_COL: 0.52
:END:

#+ATTR_LATEX: :options fontsize=\scriptsize
#+BEGIN_SRC python
  In[11]: from matplotlib.widgets import Slider
  In[12]: sfreq = Slider(axfreq, "Fréquence", 0.1, 30.0,
                         valinit=f0)
  In[13]: samp = Slider(axamp, "Amplitude", 0.1, 10.0,
                        valinit=a0)
#+END_SRC

#+BEAMER: \pause\vskip-17pt
#+ATTR_LATEX: :options fontsize=\scriptsize
#+BEGIN_SRC python
  In[14]: def update(val):
     ...:     l.set_ydata(signal(t, samp.val, sfreq.val))
     ...:     fig.canvas.draw_idle()

  In[15]: sfreq.on_changed(update)
  In[16]: samp.on_changed(update)
#+END_SRC
** Interface graphique sous =matplotlib=
#+BEAMER: \framesubtitle{Utilisation de boutons}

*** Figure
:PROPERTIES:
:BEAMER_COL: 0.5
:END:

#+BEGIN_SRC latex
  \begin{center}
    \vspace{-0.5cm}
    \includegraphics<1>[width=1.1\linewidth]{figures/mpl_widget_slider4.png}
    \includegraphics<2>[width=1.1\linewidth]{figures/mpl_widget_button.png}
    \includegraphics<3->[width=1.1\linewidth]{figures/mpl_widget_radio.png}
  \end{center}
#+END_SRC

*** Python code
:PROPERTIES:
:BEAMER_COL: 0.52
:END:

#+ATTR_LATEX: :options fontsize=\scriptsize
#+BEGIN_SRC python
  In[17]: from matplotlib.widgets import Button
  In[18]: axreset = plt.axes([0.8, 0.025, 0.1, 0.04])
  In[19]: button = Button(axreset, "Reset")
#+END_SRC

#+BEAMER: \pause\vskip-17pt
#+ATTR_LATEX: :options fontsize=\scriptsize
#+BEGIN_SRC python
  In[20]: def reset(event):
     ...:    sfreq.reset()
     ...:    samp.reset()
  In[21]: button.on_clicked(reset)
#+END_SRC

#+BEAMER: \pause\vskip-17pt
#+ATTR_LATEX: :options fontsize=\scriptsize
#+BEGIN_SRC python
  In[22]: from matplotlib.widgets import RadioButtons
  In[23]: axcolor = plt.axes([0.025, 0.5, 0.15, 0.15])
  In[24]: plt.subplots_adjust(left=0.25)
  In[25]: radio = RadioButtons(axcolor,
                               ("red", "blue", "green"),
                               active=1)

  In[26]: def update_color(label):
     ...:    l.set_color(label)
     ...:    fig.canvas.draw_idle()
  In[27]: radio.on_clicked(update_color)
#+END_SRC
** Interface graphique sous =matplotlib=

- API Documentation : http://matplotlib.org/api/widgets_api.html

- Exemples & démo. : http://matplotlib.org/examples/widgets/index.html

- Pour rappel, les exemples proposés à la préparation à l'aggrégation à
  Montrouge : http://poisson.ens.fr/Ressources/index.php
