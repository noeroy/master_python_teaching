#+AUTHOR: Xavier Garrido
#+DATE:   02/03/2017
#+OPTIONS: toc:nil ^:{}
#+LATEX_CLASS: python-class
#+LATEX_HEADER: \setcounter{chapter}{1}

* Librairie =numpy=
** Création/manipulation de tableaux

- Créer un vecteur contenant les nombres entiers de 0 à 9 puis n'afficher que les valeurs paires de
  ce vecteur. Remplacer ensuite ces valeurs paires par -1.

- Créer un vecteur de 20 valeurs flottantes réparties uniformément entre 1 et 50. À l'aide de la
  fonction =where= de =numpy=, remplacer les valeurs inférieures à 10 par 10 et celle supérieure à 30
  par 30.

- Créer les matrices suivantes en respectant le type et en 3 opérations maximum
  #+BEGIN_SRC latex
    \begin{align*}
      \begin{bmatrix}
        1&1&1&1\\
        1&1&1&1\\
        1&1&1&2\\
        1&6&1&1\\
      \end{bmatrix}&\quad
      \begin{bmatrix}
        0.& 0.& 0.& 0.& 0.\\
        2.& 0.& 0.& 0.& 0.\\
        0.& 3.& 0.& 0.& 0.\\
        0.& 0.& 4.& 0.& 0.\\
        0.& 0.& 0.& 5.& 0.\\
        0.& 0.& 0.& 0.& 6.\\
      \end{bmatrix}
    \end{align*}
  #+END_SRC
  Dans le second cas, on pourra s'aider de la méthode =diag=

- En utilisant la méthode =tile=, reproduire la matrice suivante à l'aide d'une seule commande
  #+BEGIN_SRC latex
    \begin{align*}
      \begin{bmatrix}
        4& 3& 4& 3& 4& 3\\
        2& 1& 2& 1& 2& 1\\
        4& 3& 4& 3& 4& 3\\
        2& 1& 2& 1& 2& 1\\
      \end{bmatrix}
    \end{align*}
  #+END_SRC

*** Correction                                                 :correction:
:PROPERTIES:
:HEADER-ARGS: :tangle scripts/matrix.py
:END:

-
  #+BEGIN_SRC python
    import numpy as np
    v = np.arange(0, 10)
    v[v%2 == 1] = -1
  #+END_SRC

-
  #+BEGIN_SRC ipython
    import numpy as np
    v = np.random.uniform(1, 50, 20)
    v = np.where(v < 10, 10, np.where(v > 30, 30, v))
  #+END_SRC

-
  #+BEGIN_SRC python
    import numpy as np
    M = np.ones((4,4))
    M[2,3] = 2
    M[3,1] = 6
    print(M)
  #+END_SRC

  #+BEGIN_SRC python
    M = np.diag([2, 3, 4, 5, 6], k=-1)
    M = M[:, :5]
    print(M)
  #+END_SRC

-
  #+BEGIN_SRC python
    M = np.tile([[4,3], [2, 1]], (2, 3))
    print(M)
  #+END_SRC

** Sale temps sur Seattle

- Télécharger le fichier [[https://owncloud.lal.in2p3.fr/index.php/s/HlLjdrv0C9lLYl9][=seattle2014.csv=]] qui contient pour chaque jour de l'année 2014 (colonne
  1), la hauteur des précipitations exprimé en dixième de millimètres (colonne 2) ainsi que les
  températures maximale (colonne 3) et minimale (colonne 4), exprimées en dixième de degrés Celsius,
  à Seattle.

- Charger l'ensemble des données dans un tableau =numpy= en prenant bien garde au caractère délimitant
  chaque champ puis, après avoir converti la hauteur des précipitations en centimètres et les
  températures en degré Celsius, calculer les valeurs suivantes sur chacune des données du fichier
  (hauteur des précipitations, $T_\text{min}$ et $T_\text{max}$) :
  1) moyenne, médiane et écart type
  2) valeurs minimale et maximale
  3) les quantiles à 25% et 75%

- Afficher les valeurs ci-dessus pour la période estivale

- Calculer la hauteur totale d'eau tombée à Seattle en 2014

- Dénombrer le nombre total de jours dans l'année pendant lesquels il a plu à Seattle et déterminer
  combien de ces jours étaient pairs

- Représenter la distribution de la hauteur des précipitations à l'aide de la méthode =hist= de
  =matplotlib.pyplot=

*** Correction                                                 :correction:

#+BEGIN_SRC python -n :tangle scripts/seattle1.py
  import numpy as np

  def print_report(prcp, Tmin, Tmax):

      print("Hauteur des précipitations:")
      print("  valeur moyenne = {} cm".format(np.mean(prcp)))
      print("  valeur médiane = {} cm".format(np.median(prcp)))
      print("      écart type = {} cm".format(np.std(prcp)))
      print("     valeur min. = {} cm".format(np.min(prcp)))
      print("     valeur max. = {} cm".format(np.max(prcp)))
      print("  quantile à 25% = {} cm".format(np.percentile(prcp, 25)))
      print("  quantile à 75% = {} cm".format(np.percentile(prcp, 75)))
      print("\n")

      print("Température minimale:")
      print("  valeur moyenne = {} °C".format(np.mean(Tmin)))
      print("  valeur médiane = {} °C".format(np.median(Tmin)))
      print("      écart type = {} °C".format(np.std(Tmin)))
      print("     valeur min. = {} °C".format(np.min(Tmin)))
      print("     valeur max. = {} °C".format(np.max(Tmin)))
      print("  quantile à 25% = {} °C".format(np.percentile(Tmin, 25)))
      print("  quantile à 75% = {} °C".format(np.percentile(Tmin, 75)))
      print("\n")

      print("Température maximale:")
      print("  valeur moyenne = {} °C".format(np.mean(Tmax)))
      print("  valeur médiane = {} °C".format(np.median(Tmax)))
      print("      écart type = {} °C".format(np.std(Tmax)))
      print("     valeur min. = {} °C".format(np.min(Tmax)))
      print("     valeur max. = {} °C".format(np.max(Tmax)))
      print("  quantile à 25% = {} °C".format(np.percentile(Tmax, 25)))
      print("  quantile à 75% = {} °C".format(np.percentile(Tmax, 75)))
      print("\n")

  data = np.loadtxt("./data/seattle2014.csv", delimiter=",")

  day = data[:,0]
  prcp = data[:,1]/100 # cm
  Tmax = data[:,2]/10  # °C
  Tmin = data[:,3]/10  # °C

  print("* Valeurs annuelles")
  print_report(prcp, Tmin, Tmax)

  print("* Valeurs estivales")
  summer = (day > 20140401) & (day < 20140930)
  print_report(prcp[summer], Tmin[summer], Tmax[summer])

  print("Hauteur totale d'eau en 2014 : {} cm".format(np.sum(prcp)))
  print("Nombre de jours avec pluie : {}".format(np.sum(prcp > 0)))
  print("Nombre de jours pairs avec pluie : {}".format(np.sum((prcp > 0) & (day % 2 == 0))))

  import matplotlib.pyplot as plt
  plt.hist(prcp, 40)

  plt.show()
#+END_SRC

[[file:figures/seattle2014_prcp.pdf]]

[[https://owncloud.lal.in2p3.fr/public.php?service=files&t=aeda87c5e7063d0451fa9f1c90e656a6][Télécharger la solution]]

* Librairie =matplotlib=
** Distribution spatiale de photons émis depuis une source en mouvement

On peut montrer que la distribution de photons émis depuis une source en mouvement relativiste
s'écrit
#+BEGIN_SRC latex
  \begin{align*}
    \frac{\text{d} N}{N_0}&=f(\theta)\cdot\frac{\text{d}\Omega}{4\pi}\\
  \end{align*}
#+END_SRC
où $\theta$ est l'angle zénithal et $\text{d}\Omega=\sin\theta\text{d}\theta\text{d}\phi$ dans le
référentiel statique de l'observateur. La fonction $f(\theta)$ est alors égale à
#+BEGIN_SRC latex
  \begin{align*}
    f(\theta)&=\frac{1-\beta^2}{(1-\beta\cos\theta)^2}
  \end{align*}
#+END_SRC

Représenter la fonction $f(\theta)$ dans le repère $\theta, r$ puis en représentation
polaire. Ajouter un /slider/ permettant de faire varier la vitesse $\beta=\frac{V}{c}$ de la source
par rapport à l'observateur.

*** Correction                                                 :correction:

#+BEGIN_SRC ipython :session :results raw drawer :exports none :tangle scripts/photons_gui.py
  %matplotlib
  import numpy as np
  def f(theta, beta):
        return (1-beta**2)/(1-beta*np.cos(theta))**2

  r = np.arange(0, 1, 0.0001)
  theta = 2*np.pi*r

  import matplotlib.pyplot as plt
  fig, ax = plt.subplots(subplot_kw={"projection": "polar"})
  plt.subplots_adjust(bottom=0.25, left=0.25)

  l, = ax.plot(theta, f(theta, beta=0))
  ax.set_rticks([])

  def update(val):
      y = f(theta, beta=val)
      l.set_ydata(y)
      ax.set_ylim(0, 1.1*np.max(y))
      fig.canvas.draw_idle()

  # Définition des sous-figures où afficher les sliders
  axbeta = plt.axes([0.15, 0.10, 0.75, 0.03])
  from matplotlib.widgets import Slider
  sbeta = Slider(axbeta, r"$\beta$", 0, 0.999999, valinit=0)
  sbeta.on_changed(update)
#+END_SRC
** Production de\nbsp^{11}C
Le noyau radioactif de\nbsp^{11}C est un émetteur \beta^{+} utilisé lors de tomographie par émission
de positrons. La réaction permettant la production de cet élement est la suivante
#+BEGIN_SRC latex
  \begin{align*}
    p + ^{14}_{7}\text{N}\rightarrow ^{11}_{6}\text{C}+\alpha
  \end{align*}
#+END_SRC
En tenant compte du taux de production de\nbsp^{11}C par irradiation et du nombre de noyaux se
désintégrant, on peut montrer que le nombre de noyaux de\nbsp^{11}C au cours du temps s'exprime de
la façon suivante
#+BEGIN_SRC latex
  \begin{align*}
    \left\{
      \begin{array}{lll}
        n(t)&=\frac{n_i}{\lambda}\left(1 - e^{-\lambda t}\right)&\text{si } t \leq t_0\\
        &=n(t_0)\,e^{-\lambda (t-t_0)}&\text{si } t > t_0
      \end{array}
      \right.
  \end{align*}
#+END_SRC
où $\lambda=\frac{\ln2}{T_{1/2}}$ et $T_{1/2}$ = 20.36 minutes. $n_i$ correspond au taux
d'irradition et est égal à 3 10^{8} noyaux/s. Représenter $n(t)$ pour $t_0$ = 3
heures[fn:1cca6ecd258813f0].

Ajouter finalement trois /sliders/ respectivement $n_i$, $T_{1/2}$ et $t_0$ et faire en sorte que la
figure se reconstruise à chaque nouvelle valeur de ces paramètres.

*** Correction                                                 :correction:

#+BEGIN_SRC python -n :tangle scripts/nc11_gui.py
  import numpy as np

  # Définition des constantes du problème
  ni  = 3e8   # noyaux/s
  T12 = 20.36 # min
  t0  = 3     # hours

  def n(t, ni=ni, t0=t0, T12=T12):
      T12 /= 60  # hours
      ni *= 3600 # noyaux/h
      l = np.log(2)/T12
      conds = [t <= t0, t > t0]
      funcs = [lambda t: ni/l*(1-np.exp(-l*t)),
               lambda t: ni/l*(1-np.exp(-l*t0))*np.exp(-l*(t-t0))]
      return np.piecewise(t, conds, funcs)

  t = np.linspace(0, 10, 1000) #hours

  import matplotlib.pyplot as plt
  fig, ax = plt.subplots()
  l, = plt.plot(t, n(t))
  plt.xlabel("temps [heures]")
  plt.ylabel(r"$n(^{11}\mathrm{C})$")

  # Définition des sous-figures où afficher les sliders
  axni  = plt.axes([0.25, 0.10, 0.65, 0.03])
  axt12 = plt.axes([0.25, 0.15, 0.65, 0.03])
  axt0  = plt.axes([0.25, 0.20, 0.65, 0.03])

  plt.subplots_adjust(bottom=0.35)

  from matplotlib.widgets import Slider
  sni = Slider(axni, r"$n_i [\times10^8]\mathrm{/s}$", 1, 10, valinit=ni/1e8)
  st12 = Slider(axt12, r"$T_{1/2}$ [min]", 1, 60, valinit=T12)
  st0 = Slider(axt0, r"$t_{0}$ [h]", 1, 10, valinit=t0)

  def update(val):
      nx = n(t, sni.val*1e8, st0.val, st12.val)
      l.set_ydata(nx)
      ax.set_ylim(ax.get_ylim()[0], 1.1*np.max(nx))
      fig.canvas.draw_idle()

  sni.on_changed(update)
  st12.on_changed(update)
  st0.on_changed(update)

  plt.show()
#+END_SRC


[[file:figures/carbon11_gui.png]]

* Footnotes

[fn:1cca6ecd258813f0] on pourra s'aider ou pas de la fonction =piecewise= de =numpy=
