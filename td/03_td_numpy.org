#+TITLE:  Librairie =numpy= & =pandas=
#+AUTHOR: Xavier Garrido
#+DATE:   15/01/2020
#+OPTIONS: toc:nil ^:{}
#+LATEX_HEADER: \setcounter{chapter}{2}

#+COMMENT: https://www.machinelearningplus.com/101-numpy-exercises-python/

* Création/manipulation de tableaux

- Créer un vecteur contenant les nombres entiers de 0 à 9 puis n'afficher que les valeurs paires de
  ce vecteur. Remplacer ensuite ces valeurs paires par -1.

- Créer un vecteur de 20 valeurs flottantes réparties uniformément entre 1 et 50. À l'aide de la
  fonction =where= de =numpy=, remplacer les valeurs inférieures à 10 par 10 et celle supérieure à 30
  par 30.

- Créer les matrices suivantes en respectant le type et en 3 opérations maximum
  #+BEGIN_SRC latex
    \begin{align*}
      \begin{bmatrix}
        1&1&1&1\\
        1&1&1&1\\
        1&1&1&2\\
        1&6&1&1\\
      \end{bmatrix}&\quad
      \begin{bmatrix}
        0.& 0.& 0.& 0.& 0.\\
        2.& 0.& 0.& 0.& 0.\\
        0.& 3.& 0.& 0.& 0.\\
        0.& 0.& 4.& 0.& 0.\\
        0.& 0.& 0.& 5.& 0.\\
        0.& 0.& 0.& 0.& 6.\\
      \end{bmatrix}
    \end{align*}
  #+END_SRC
  Dans le second cas, on pourra s'aider de la méthode =diag=

- En utilisant la méthode =tile=, reproduire la matrice suivante à l'aide d'une seule commande
  #+BEGIN_SRC latex
    \begin{align*}
      \begin{bmatrix}
        4& 3& 4& 3& 4& 3\\
        2& 1& 2& 1& 2& 1\\
        4& 3& 4& 3& 4& 3\\
        2& 1& 2& 1& 2& 1\\
      \end{bmatrix}
    \end{align*}
  #+END_SRC

** Correction                                                   :correction:
:PROPERTIES:
:HEADER-ARGS: :tangle scripts/matrix.py
:END:

-
  #+BEGIN_SRC python
    import numpy as np
    v = np.arange(0, 10)
    v[v%2 == 1] = -1
  #+END_SRC

-
  #+BEGIN_SRC ipython
    import numpy as np
    v = np.random.uniform(1, 50, 20)
    v = np.where(v < 10, 10, np.where(v > 30, 30, v))
  #+END_SRC

-
  #+BEGIN_SRC python
    import numpy as np
    M = np.ones((4,4))
    M[2,3] = 2
    M[3,1] = 6
    print(M)
  #+END_SRC

  #+BEGIN_SRC python
    import numpy as np
    M = np.diag([2, 3, 4, 5, 6], k=-1)
    M = M[:, :5]
    print(M)
  #+END_SRC

-
  #+BEGIN_SRC python
    import numpy as np
    M = np.tile([[4,3], [2, 1]], (2, 3))
    print(M)
  #+END_SRC

[[https://owncloud.lal.in2p3.fr/public.php?service=files&t=ca57174417a91df160a81971c2c57db1][Télécharger les solutions]]

* Fonctions universelles

- Créer un tableau à une dimension contenant 1 million de valeurs aléatoires comprises entre 1 et
  100

- Créer une fonction =inverse= qui retournera un second tableau résultat de l'opération d'inversion du
  premier tableau

- À l'aide de la fonction intégrée =%timeit= de l'interpréteur =ipython=, estimer le temps moyen
  nécessaire à l'exécution de la fonction =inverse=

- Estimer ce même temps d'exécution, en utilisant l'opérateur division

** Correction                                                   :correction:

#+BEGIN_SRC python
  In [1]: def inverse(value):
     ...:     output = np.empty(len(values))
     ...:     for i in range(len(values)):
     ...:         output[i] = 1./values[i]
     ...:     return output
     ...:

  In [2]: v = np.random.randint(1, 100, 1000000)

  In [3]: %timeit inverse(v)
  1 loop, best of 3: 2.46 s per loop

  In [4]: %timeit 1./v
  100 loops, best of 3: 6.45 ms per loop
#+END_SRC

* Sale temps sur Seattle

- Télécharger le fichier [[https://owncloud.lal.in2p3.fr/index.php/s/HlLjdrv0C9lLYl9][=seattle2014.csv=]] qui contient pour chaque jour de l'année 2014 (colonne
  1), la hauteur des précipitations exprimé en dixième de millimètres (colonne 2) ainsi que les
  températures maximale (colonne 3) et minimale (colonne 4), exprimées en dixième de degrés Celsius,
  à Seattle.

- Charger l'ensemble des données dans un tableau =numpy= en prenant bien garde au caractère délimitant
  chaque champ puis, après avoir converti la hauteur des précipitations en centimètres et les
  températures en degré Celsius, calculer les valeurs suivantes sur chacune des données du fichier
  (hauteur des précipitations, $T_\text{min}$ et $T_\text{max}$) :
  1) moyenne, médiane et écart type
  2) valeurs minimale et maximale
  3) les quantiles à 25% et 75%

- Afficher les valeurs ci-dessus pour la période estivale

- Calculer la hauteur totale d'eau tombée à Seattle en 2014

- Dénombrer le nombre total de jours dans l'année pendant lesquels il a plu à Seattle et déterminer
  combien de ces jours étaient pairs

** Correction                                                   :correction:

#+BEGIN_SRC python -n :tangle scripts/seattle1.py
  import numpy as np

  def print_report(prcp, Tmin, Tmax):

      print("Hauteur des précipitations:")
      print("  valeur moyenne = {} cm".format(np.mean(prcp)))
      print("  valeur médiane = {} cm".format(np.median(prcp)))
      print("      écart type = {} cm".format(np.std(prcp)))
      print("     valeur min. = {} cm".format(np.min(prcp)))
      print("     valeur max. = {} cm".format(np.max(prcp)))
      print("  quantile à 25% = {} cm".format(np.percentile(prcp, 25)))
      print("  quantile à 75% = {} cm".format(np.percentile(prcp, 75)))
      print("\n")

      print("Température minimale:")
      print("  valeur moyenne = {} °C".format(np.mean(Tmin)))
      print("  valeur médiane = {} °C".format(np.median(Tmin)))
      print("      écart type = {} °C".format(np.std(Tmin)))
      print("     valeur min. = {} °C".format(np.min(Tmin)))
      print("     valeur max. = {} °C".format(np.max(Tmin)))
      print("  quantile à 25% = {} °C".format(np.percentile(Tmin, 25)))
      print("  quantile à 75% = {} °C".format(np.percentile(Tmin, 75)))
      print("\n")

      print("Température maximale:")
      print("  valeur moyenne = {} °C".format(np.mean(Tmax)))
      print("  valeur médiane = {} °C".format(np.median(Tmax)))
      print("      écart type = {} °C".format(np.std(Tmax)))
      print("     valeur min. = {} °C".format(np.min(Tmax)))
      print("     valeur max. = {} °C".format(np.max(Tmax)))
      print("  quantile à 25% = {} °C".format(np.percentile(Tmax, 25)))
      print("  quantile à 75% = {} °C".format(np.percentile(Tmax, 75)))
      print("\n")

  data = np.loadtxt("./data/seattle2014.csv", delimiter=",")

  day = data[:,0]
  prcp = data[:,1]/100 # cm
  Tmax = data[:,2]/10  # °C
  Tmin = data[:,3]/10  # °C

  print("* Valeurs annuelles")
  print_report(prcp, Tmin, Tmax)

  print("* Valeurs estivales")
  summer = (day > 20140401) & (day < 20140930)
  print_report(prcp[summer], Tmin[summer], Tmax[summer])

  print("Hauteur totale d'eau en 2014 : {} cm".format(np.sum(prcp)))
  print("Nombre de jours avec pluie : {}".format(np.sum(prcp > 0)))
  print("Nombre de jours pairs avec pluie : {}".format(np.sum((prcp > 0) & (day % 2 == 0))))
#+END_SRC

[[https://owncloud.lal.in2p3.fr/index.php/s/agKz0cf6LZjujX5][Télécharger la solution]]
* Manipulation d'images

Une image n'est rien d'autre qu'une matrice où chaque pixel contient une information
colorimétrique. La notion de tableau /à la/ =numpy= est donc parfaitement adaptée à la représentation de
ces objets.

En fonction du système colorimétrique choisi, chaque pixel peut être:
- un nombre entier compris entre 0 et 255 ou un nombre flottant compris entre 0.0 et 1.0 quantifiant
  le niveau de gris du pixel,
- un triplet de valeurs $(R, V, B)$ soit entières (entre 0 et 255) soit flottantes (entre 0.0 et
  1.0) donnant respectivement le niveau de rouge, vert et bleu du pixel,
- un triplet de valeurs ($\ell, \alpha, \beta$) correspondant à la luminosité $\ell$, l'opposition
  bleu-jaune $\alpha$ et l'opposition vert-rouge $\beta$,
- ...

Les opérations mathématiques sur des tableaux =numpy= permettent ainsi de changer d'espaces
colorimétriques en minimisant le nombre d'opérations. De même, la sélection par masque permet
d'appliquer des transformations à des sous-espaces de l'image.

Dans la suite de l'exercice, on s'aidera des fonctions intégrées à la librairie =matplotlib= pour
lire et pour représenter une image au format =png= ou =jpeg=. On utilisera en particulier les
fonctions =imread= et =imshow= pour lire puis afficher l'image =matplotlib= comme suit
#+BEGIN_SRC python
  import matplotlib.pyplot as plt
  img = plt.imread("mon_image.png")
  plt.imshow(img)
#+END_SRC


** Changement d'espace colorimétrique

1) Charger l'image [[https://owncloud.lal.in2p3.fr/index.php/s/0hLYpI8AjA1QeUS][=balloon.jpg=]] puis
   afficher la. Quelle est la taille de l'image ? Dans quel système colorimétrique est-elle
   représentée ?

2) La calcul de la luminance =Y= d'un pixel (également appelé niveau de gris) se fait, à partir du
   système colorimétrique $(R, V, B)$, par la transformation
   #+BEGIN_SRC latex
     \begin{align*}
       Y &= 0.2126\times R+0.7152\times V+0.0722\times B
     \end{align*}
   #+END_SRC
   Convertir l'image initiale en niveau de gris et la représenter en utilisant l'échelle de couleur
   ~cmap="gray"~ (à passer en argument de la fonction =imshow=).

3) Le passage à l'espace $(\ell, \alpha, \beta)$ se fait par le biais de l'espace intermédiaire $(L,
   M, S)$
   #+BEGIN_SRC latex
     \begin{align*}
      \begin{pmatrix}
      L\\M\\S
      \end{pmatrix}
      &=\begin{pmatrix}
      0.3811&0.5783&0.0401\\
      0.1967&0.7244&0.0781\\
      0.0241&0.1288&0.8444
      \end{pmatrix}
      \begin{pmatrix}
      R\\V\\B
      \end{pmatrix}\\
      \begin{pmatrix}
      \ell\\\alpha\\\beta
      \end{pmatrix}
      &=\begin{pmatrix}
      1/\sqrt{3}&0&0\\
      0&1/\sqrt{6}&0\\
      0&0&1/\sqrt{2}
      \end{pmatrix}
      \begin{pmatrix}
      \ln L\\\ln M\\\ln S
      \end{pmatrix}
     \end{align*}
   #+END_SRC
   Convertir l'image initiale dans l'espace colorimétrique $\ell, \alpha, \beta$.
*** Correction                                                 :correction:
1)
   #+BEGIN_SRC python
     import matplotlib.pyplot as plt
     img = plt.imread("data/balloon.jpg")
     plt.imshow(img)
     print("Taille de l'image {}x{} pixels".format(*img.shape[:2]))
   #+END_SRC

2)
   #+BEGIN_SRC python
     img1 = np.dot(img, [0.2126, 0.7152, 0.0722])
     # ou img1 = img @ [0.2126, 0.7152, 0.0722] depuis Python 3.5
     plt.imshow(img1, cmap="gray")
   #+END_SRC

3)
   #+BEGIN_SRC python
     RVB2LMS = np.array([[0.3811, 0.5783, 0.0401], [0.1967, 0.7244, 0.0781], [0.0241, 0.1228, 0.8444]])
     LMS = np.dot(img, RVB2LMS)

   #+END_SRC
